---
const defaultScenario = {
  meta: { schemaVersion: "1.0.0", title: "New VN" },
  entryNodeId: "n_start",
  nodes: [
    { id: "n_start", type: "scene", next: "n_end", data: { text: "첫 장면입니다." } },
    { id: "n_end", type: "ending", data: { endingId: "end_1", title: "엔딩" } }
  ]
};
const playerBaseUrl = import.meta.env.PUBLIC_PLAYER_BASE_URL ?? "http://localhost:4322";
---

<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VN Studio</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap");

      :root {
        --bg-top: #292247;
        --bg-bottom: #151225;
        --panel: #251f44;
        --panel-soft: #2f2860;
        --line: #a8c5ff;
        --line-shadow: #394f84;
        --ink: #eef5ff;
        --muted: #9fb0d1;
        --accent: #50e2b7;
        --accent-2: #ffcb61;
        --danger: #ff7697;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--ink);
        font-family: "VT323", monospace;
        font-size: 28px;
        background:
          radial-gradient(circle at 8% 12%, #4b3f90 0, transparent 40%),
          radial-gradient(circle at 90% 88%, #3a3f9a 0, transparent 35%),
          linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
      }

      .layout {
        display: grid;
        grid-template-columns: 290px 1fr 340px;
        height: 100vh;
        gap: 12px;
        padding: 12px;
        overflow: hidden;
      }

      .panel {
        border: 3px solid var(--line);
        box-shadow:
          0 0 0 3px var(--line-shadow),
          0 10px 0 rgba(0, 0, 0, 0.2);
        background: linear-gradient(180deg, var(--panel-soft), var(--panel));
        padding: 12px;
        display: grid;
        gap: 10px;
        align-content: start;
        min-height: 0;
        overflow: auto;
      }

      .editor-panel {
        grid-template-rows: auto 1fr;
        overflow: hidden;
      }

      .panel-sticky {
        position: sticky;
        top: 0;
        z-index: 4;
        background: linear-gradient(180deg, var(--panel-soft), var(--panel));
        padding-bottom: 8px;
      }

      h1,
      h2,
      h3 {
        margin: 0;
      }

      h1,
      h2 {
        font-family: "Press Start 2P", monospace;
        font-size: 13px;
        letter-spacing: 0.04em;
        text-shadow: 2px 2px 0 #000;
      }

      h3 {
        font-size: 22px;
        color: var(--muted);
      }

      .stack {
        display: grid;
        gap: 8px;
      }

      .group {
        border: 2px solid rgba(168, 197, 255, 0.45);
        background: rgba(13, 18, 39, 0.35);
        padding: 10px;
      }

      label {
        display: grid;
        gap: 6px;
        color: #dce8ff;
      }

      input,
      select,
      textarea,
      button {
        width: 100%;
        border: 2px solid #dce9ff;
        background: #ecf5ff;
        color: #1e2a45;
        font: inherit;
        font-size: 24px;
        padding: 8px 10px;
      }

      textarea {
        resize: vertical;
        min-height: 112px;
      }

      button {
        cursor: pointer;
        background: linear-gradient(180deg, #5a80c9, #43619c);
        color: #f7fbff;
        transition: transform 120ms steps(2), filter 120ms steps(2);
      }

      button:hover {
        transform: translate(-1px, -1px);
        filter: brightness(1.08);
      }

      .primary {
        background: linear-gradient(180deg, #3ed2a2, #289172);
      }

      .warn {
        background: linear-gradient(180deg, #ff8f7d, #d26155);
      }

      .canvas {
        min-height: 420px;
        border: 2px dashed rgba(168, 197, 255, 0.6);
        background:
          linear-gradient(rgba(255, 255, 255, 0.06) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.06) 1px, transparent 1px),
          rgba(13, 17, 34, 0.35);
        background-size: 22px 22px;
        position: relative;
        height: 100%;
        overflow: auto;
      }

      .canvas-content {
        position: relative;
        min-width: 100%;
        min-height: 100%;
      }

      :global(.node) {
        position: absolute;
        width: 220px;
        border: 2px solid #cfe1ff;
        box-shadow: inset 0 0 0 2px #405b93;
        background: linear-gradient(180deg, #3b3368, #2f2857);
        color: var(--ink);
        text-align: left;
        user-select: none;
        z-index: 2;
        cursor: grab;
        touch-action: none;
        padding: 10px;
        font-family: "VT323", monospace;
        font-size: 24px;
      }

      :global(.node.dragging) {
        cursor: grabbing;
      }

      :global(.node.connect-target) {
        border-color: #50e2b7;
        box-shadow:
          inset 0 0 0 2px #1f6e5b,
          0 0 0 2px rgba(80, 226, 183, 0.4);
      }

      :global(.node.selected) {
        border-color: var(--accent-2);
        box-shadow:
          inset 0 0 0 2px #8d6a2b,
          0 0 0 2px rgba(255, 203, 97, 0.35);
      }

      :global(.node-meta) {
        display: flex;
        justify-content: space-between;
        color: var(--accent);
        font-family: "Press Start 2P", monospace;
        font-size: 10px;
        margin-bottom: 6px;
      }

      :global(.node-text) {
        color: #eff5ff;
      }

      :global(.node-row) {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      :global(.connect-handle) {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        border: 2px solid #dce9ff;
        background: #50e2b7;
        flex-shrink: 0;
        cursor: crosshair;
      }

      :global(.edge-layer) {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      :global(.edge-line) {
        stroke: rgba(168, 197, 255, 0.85);
        stroke-width: 2;
      }

      :global(.edge-label) {
        fill: #ffcb61;
        font-size: 10px;
        font-family: "Press Start 2P", monospace;
      }

      .mono {
        font-family: "Press Start 2P", monospace;
        font-size: 10px;
      }

      .badge {
        display: inline-block;
        min-width: 38px;
        text-align: center;
        border: 2px solid #dce9ff;
        background: #3f66a7;
        color: #f3f8ff;
        padding: 2px 8px;
      }

      .issues {
        max-height: 230px;
        overflow: auto;
        border: 2px solid rgba(168, 197, 255, 0.5);
        background: rgba(16, 20, 42, 0.55);
        padding: 8px;
      }

      .issue {
        padding: 6px 0;
        border-bottom: 1px dashed rgba(168, 197, 255, 0.35);
      }

      .error {
        color: var(--danger);
      }

      .ok {
        color: var(--accent);
      }

      .hidden {
        display: none !important;
      }

      .choice-options {
        display: grid;
        gap: 8px;
      }

      .choice-option-row {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 6px;
        align-items: center;
      }

      .choice-option-row button {
        width: auto;
        min-width: 80px;
      }

      .toolbar {
        display: grid;
        grid-template-columns: repeat(8, minmax(120px, 1fr));
        gap: 8px;
        position: sticky;
        top: 0;
        z-index: 5;
        background: linear-gradient(180deg, var(--panel-soft), var(--panel));
        padding-bottom: 8px;
      }

      .divider {
        border: 0;
        border-top: 2px solid rgba(168, 197, 255, 0.35);
        margin: 0;
      }

      @media (max-width: 1200px) {
        .layout {
          grid-template-columns: 1fr;
          height: auto;
          overflow: visible;
        }

        .toolbar {
          position: static;
          grid-template-columns: repeat(3, minmax(120px, 1fr));
        }

        .panel {
          overflow: visible;
        }
      }

      @media (max-width: 720px) {
        body {
          font-size: 24px;
        }

        .toolbar {
          grid-template-columns: 1fr 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="layout">
      <section class="panel">
        <div class="panel-sticky">
          <h1>PIXEL VN STUDIO</h1>
          <h3>Project + Scenario Authoring</h3>
        </div>

        <div class="group stack">
          <label>Project Name <input id="projectName" value="My VN" /></label>
          <label>Project Slug <input id="projectSlug" value="my-vn" /></label>
          <button class="primary" id="createProjectBtn">Create Project</button>
          <div id="projectStatus" class="mono"></div>
        </div>

        <hr class="divider" />

        <div class="group stack">
          <h2>ACTOR CONTEXT</h2>
          <label>Role
            <select id="role">
              <option value="owner">owner</option>
              <option value="editor" selected>editor</option>
              <option value="viewer">viewer</option>
            </select>
          </label>
          <label>Plan
            <select id="plan">
              <option value="free" selected>free</option>
              <option value="pro">pro</option>
            </select>
          </label>
          <label>User ID <input id="userId" value="00000000-0000-0000-0000-000000000010" /></label>
          <label>Org ID <input id="orgId" value="00000000-0000-0000-0000-000000000020" /></label>
        </div>
      </section>

      <section class="panel editor-panel">
        <div class="toolbar">
          <button id="addScene">+ Scene</button>
          <button id="addChoice">+ Choice</button>
          <button id="addEnding">+ Ending</button>
          <button id="saveScenario" class="primary">Save Scenario</button>
          <button id="validateScenario">Validate</button>
          <button id="connectNode">Connect (Drag)</button>
          <button id="buildSeo" class="warn">Build SEO</button>
          <button id="openPlayer">Play Test</button>
        </div>
        <div class="canvas" id="nodeCanvas"></div>
      </section>

      <aside class="panel">
        <div class="panel-sticky">
          <h2>NODE PROPERTIES</h2>
          <h3 id="selectedNodeLabel">No node selected</h3>
        </div>

        <div class="group stack">
          <label id="nodeTextField"><span id="nodeTextLabel">Node Text</span>
            <textarea id="nodeText" rows="5" placeholder="scene text"></textarea>
          </label>
          <label id="nodeSpeakerField"><span>Character Name</span>
            <input id="nodeSpeaker" placeholder="Narrator" />
          </label>
          <label id="nodeTextSpeedField"><span>Text Speed (ms, 0 = instant)</span>
            <input id="nodeTextSpeed" type="number" min="0" max="96" step="1" placeholder="24" />
          </label>
          <label id="nodeNextField"><span>Next Node ID</span>
            <input id="nodeNext" placeholder="n_end" />
          </label>
          <div id="choiceOptionsField" class="hidden">
            <span>Choice Options</span>
            <div id="choiceOptionsEditor" class="choice-options"></div>
            <button id="addChoiceOption">+ Option</button>
          </div>
          <label>Background URL
            <input id="nodeBackground" placeholder="/assets/bg/school.jpg" />
          </label>
          <label>Character Image URL
            <input id="nodeCharacterImage" placeholder="/assets/char/hero.png" />
          </label>
          <label>BGM URL
            <input id="nodeMusic" placeholder="/assets/bgm/theme.mp3" />
          </label>
          <button id="deleteNode" class="warn">Delete Node</button>
        </div>

        <hr class="divider" />

        <div class="stack">
          <h2>VALIDATION ISSUES <span id="issueCount" class="badge">0</span></h2>
          <div id="issues" class="issues"></div>
        </div>

        <hr class="divider" />

        <div class="stack">
          <h2>ACTIVITY</h2>
          <div id="activity" class="mono"></div>
        </div>
      </aside>
    </main>

    <script type="module" define:vars={{ defaultScenario, playerBaseUrl }}>
      const state = {
        projectId: "p1",
        scenarioVersion: 1,
        selectedNodeId: null,
        connectFromId: null,
        draggingNodeId: null,
        connectDrag: null,
        connectHoverNodeId: null,
        scenario: structuredClone(defaultScenario),
        uiPositions: {}
      };

      const el = {
        projectName: document.getElementById("projectName"),
        projectSlug: document.getElementById("projectSlug"),
        createProjectBtn: document.getElementById("createProjectBtn"),
        projectStatus: document.getElementById("projectStatus"),
        role: document.getElementById("role"),
        plan: document.getElementById("plan"),
        userId: document.getElementById("userId"),
        orgId: document.getElementById("orgId"),
        nodeCanvas: document.getElementById("nodeCanvas"),
        selectedNodeLabel: document.getElementById("selectedNodeLabel"),
        nodeTextField: document.getElementById("nodeTextField"),
        nodeTextLabel: document.getElementById("nodeTextLabel"),
        nodeText: document.getElementById("nodeText"),
        nodeSpeakerField: document.getElementById("nodeSpeakerField"),
        nodeSpeaker: document.getElementById("nodeSpeaker"),
        nodeTextSpeedField: document.getElementById("nodeTextSpeedField"),
        nodeTextSpeed: document.getElementById("nodeTextSpeed"),
        nodeNextField: document.getElementById("nodeNextField"),
        nodeNext: document.getElementById("nodeNext"),
        choiceOptionsField: document.getElementById("choiceOptionsField"),
        choiceOptionsEditor: document.getElementById("choiceOptionsEditor"),
        addChoiceOption: document.getElementById("addChoiceOption"),
        nodeBackground: document.getElementById("nodeBackground"),
        nodeCharacterImage: document.getElementById("nodeCharacterImage"),
        nodeMusic: document.getElementById("nodeMusic"),
        deleteNode: document.getElementById("deleteNode"),
        addScene: document.getElementById("addScene"),
        addChoice: document.getElementById("addChoice"),
        addEnding: document.getElementById("addEnding"),
        saveScenario: document.getElementById("saveScenario"),
        validateScenario: document.getElementById("validateScenario"),
        connectNode: document.getElementById("connectNode"),
        buildSeo: document.getElementById("buildSeo"),
        openPlayer: document.getElementById("openPlayer"),
        issues: document.getElementById("issues"),
        issueCount: document.getElementById("issueCount"),
        activity: document.getElementById("activity")
      };

      function headers() {
        return {
          "content-type": "application/json",
          "x-user-role": el.role.value,
          "x-plan-tier": el.plan.value,
          "x-user-id": el.userId.value,
          "x-org-id": el.orgId.value
        };
      }

      function draftKey() {
        const ref = state.projectId || el.projectSlug.value || "default";
        return `vn.studio.draft.${ref}`;
      }

      function persistDraft() {
        const snapshot = {
          projectId: state.projectId,
          scenarioVersion: state.scenarioVersion,
          scenario: state.scenario,
          uiPositions: state.uiPositions,
          projectName: el.projectName.value,
          projectSlug: el.projectSlug.value
        };
        localStorage.setItem(draftKey(), JSON.stringify(snapshot));
      }

      function restoreDraft() {
        const currentRef = state.projectId || el.projectSlug.value;
        if (!currentRef) {
          return;
        }
        const raw = localStorage.getItem(`vn.studio.draft.${currentRef}`);
        if (!raw) {
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          if (parsed.projectId) state.projectId = parsed.projectId;
          if (Number.isInteger(parsed.scenarioVersion)) state.scenarioVersion = parsed.scenarioVersion;
          if (parsed.projectName) el.projectName.value = parsed.projectName;
          if (parsed.projectSlug) el.projectSlug.value = parsed.projectSlug;
          if (parsed.scenario?.entryNodeId && Array.isArray(parsed.scenario?.nodes)) {
            state.scenario = parsed.scenario;
          }
          if (parsed.uiPositions && typeof parsed.uiPositions === "object") {
            state.uiPositions = parsed.uiPositions;
          }
          log("Draft restored from local storage.");
        } catch (error) {
          log(`Draft restore failed: ${error.message}`, true);
        }
      }

      function log(message, error = false) {
        const line = document.createElement("div");
        line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        line.className = error ? "error" : "ok";
        el.activity.prepend(line);
      }

      function ensureNodePosition(nodeId, fallbackIndex = 0) {
        if (state.uiPositions[nodeId]) {
          return state.uiPositions[nodeId];
        }
        const position = {
          x: 24 + (fallbackIndex % 4) * 250,
          y: 24 + Math.floor(fallbackIndex / 4) * 170
        };
        state.uiPositions[nodeId] = position;
        return position;
      }

      function getEdgeList() {
        const edges = [];
        for (const node of state.scenario.nodes) {
          if (node.type === "scene" && node.next) {
            edges.push({ from: node.id, to: node.next, label: "next" });
          }
          if (node.type === "jump" && node.data?.to) {
            edges.push({ from: node.id, to: node.data.to, label: "jump" });
          }
          if (node.type === "choice") {
            (node.data?.options ?? []).forEach((option, index) => {
              if (option?.to) {
                edges.push({ from: node.id, to: option.to, label: `opt${index + 1}` });
              }
            });
          }
          if (node.type === "condition") {
            (node.data?.branches ?? []).forEach((branch, index) => {
              if (branch?.to) {
                edges.push({ from: node.id, to: branch.to, label: `br${index + 1}` });
              }
            });
          }
        }
        return edges;
      }

      function connectNodes(fromId, toId) {
        const source = state.scenario.nodes.find((n) => n.id === fromId);
        if (!source) {
          return;
        }
        source.data = source.data || {};
        if (source.type === "scene") {
          source.next = toId;
        } else if (source.type === "jump") {
          source.data.to = toId;
        } else if (source.type === "choice") {
          const options = Array.isArray(source.data.options) ? source.data.options : [];
          const alreadyLinked = options.some((opt) => opt?.to === toId);
          if (alreadyLinked) {
            log(`Choice already linked to ${toId}`);
            return;
          }
          if (options.length >= 8) {
            log("Choice options are limited to 8.", true);
            return;
          }
          const nextIndex = options.length + 1;
          options.push({
            id: `opt_${nextIndex}`,
            label: `선택 ${nextIndex}`,
            to: toId
          });
          source.data.options = options;
        } else if (source.type === "condition") {
          const branches = source.data.branches || [];
          if (branches.length === 0) {
            source.data.branches = [{ when: "default", to: toId }];
          } else {
            branches[0].to = toId;
          }
        } else {
          log(`${source.type} node does not support outgoing links.`, true);
          return;
        }
        persistDraft();
        if (state.selectedNodeId === source.id) {
          selectNode(source.id);
        } else {
          renderNodes();
        }
        el.connectNode.textContent = "Connect (Drag)";
        log(`Connected ${fromId} -> ${toId}`);
      }

      function canvasPointFromClient(clientX, clientY) {
        const rect = el.nodeCanvas.getBoundingClientRect();
        return {
          x: clientX - rect.left + el.nodeCanvas.scrollLeft,
          y: clientY - rect.top + el.nodeCanvas.scrollTop
        };
      }

      function findNodeIdFromClient(clientX, clientY) {
        const element = document.elementFromPoint(clientX, clientY);
        const nodeEl = element?.closest?.(".node[data-node-id]");
        if (!nodeEl) {
          return null;
        }
        return nodeEl.getAttribute("data-node-id");
      }

      function renderNodes() {
        el.nodeCanvas.innerHTML = "";
        const content = document.createElement("div");
        content.className = "canvas-content";
        el.nodeCanvas.appendChild(content);

        const edgeLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        edgeLayer.setAttribute("class", "edge-layer");
        content.appendChild(edgeLayer);

        state.scenario.nodes.forEach((node, index) => ensureNodePosition(node.id, index));
        const maxX = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.x ?? 0) + 260), 1200);
        const maxY = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.y ?? 0) + 180), 900);
        content.style.width = `${maxX}px`;
        content.style.height = `${maxY}px`;

        for (const edge of getEdgeList()) {
          const fromPos = state.uiPositions[edge.from];
          const toPos = state.uiPositions[edge.to];
          if (!fromPos || !toPos) {
            continue;
          }
          const x1 = fromPos.x + 220;
          const y1 = fromPos.y + 46;
          const x2 = toPos.x;
          const y2 = toPos.y + 46;

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", String(x1));
          line.setAttribute("y1", String(y1));
          line.setAttribute("x2", String(x2));
          line.setAttribute("y2", String(y2));
          line.setAttribute("class", "edge-line");
          edgeLayer.appendChild(line);

          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
          label.setAttribute("x", String((x1 + x2) / 2));
          label.setAttribute("y", String((y1 + y2) / 2 - 4));
          label.setAttribute("class", "edge-label");
          label.textContent = edge.label;
          edgeLayer.appendChild(label);
        }

        if (state.connectDrag) {
          const fromPos = state.uiPositions[state.connectDrag.fromId];
          if (fromPos) {
            const x1 = fromPos.x + 220;
            const y1 = fromPos.y + 46;
            const x2 = state.connectDrag.x;
            const y2 = state.connectDrag.y;
            const preview = document.createElementNS("http://www.w3.org/2000/svg", "line");
            preview.setAttribute("x1", String(x1));
            preview.setAttribute("y1", String(y1));
            preview.setAttribute("x2", String(x2));
            preview.setAttribute("y2", String(y2));
            preview.setAttribute("class", "edge-line");
            preview.setAttribute("stroke-dasharray", "5 4");
            edgeLayer.appendChild(preview);
          }
        }

        for (const node of state.scenario.nodes) {
          const div = document.createElement("div");
          const isSelected = state.selectedNodeId === node.id || state.connectFromId === node.id;
          const isDragging = state.draggingNodeId === node.id;
          const isConnectTarget = state.connectHoverNodeId === node.id;
          div.className = `node ${isSelected ? "selected" : ""} ${isDragging ? "dragging" : ""} ${isConnectTarget ? "connect-target" : ""}`;
          div.setAttribute("data-node-id", node.id);
          const pos = state.uiPositions[node.id];
          div.style.left = `${pos.x}px`;
          div.style.top = `${pos.y}px`;
          div.innerHTML = `
            <div class="node-meta"><span>${node.id}</span><span>${node.type}</span></div>
            <div class="node-text">${node.data?.text ?? node.data?.prompt ?? "(no text)"}</div>
            <div class="node-row">
              <span class="mono">next: ${node.next ?? node.data?.to ?? "-"} / opts:${node.type === "choice" ? (node.data?.options?.length ?? 0) : "-"}</span>
              <span class="connect-handle" data-role="connect-handle" title="Drag to connect"></span>
            </div>
            <div class="mono">bg:${node.data?.background ? "y" : "-"} char:${node.data?.characterImage ? "y" : "-"} bgm:${node.data?.music ? "y" : "-"} spd:${Number.isFinite(Number(node.data?.textSpeed)) ? Math.round(Number(node.data?.textSpeed)) : "-"}</div>
          `;
          div.onpointerdown = (event) => {
            const isHandle = event.target?.closest?.("[data-role='connect-handle']");
            if (isHandle) {
              event.preventDefault();
              event.stopPropagation();
              state.connectDrag = {
                fromId: node.id,
                ...canvasPointFromClient(event.clientX, event.clientY)
              };
              state.connectHoverNodeId = null;
              state.connectFromId = node.id;
              const onMove = (moveEvent) => {
                state.connectDrag = {
                  fromId: node.id,
                  ...canvasPointFromClient(moveEvent.clientX, moveEvent.clientY)
                };
                const hovered = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);
                state.connectHoverNodeId = hovered && hovered !== node.id ? hovered : null;
                renderNodes();
              };
              const onUp = () => {
                window.removeEventListener("pointermove", onMove);
                window.removeEventListener("pointerup", onUp);
                if (state.connectHoverNodeId && state.connectHoverNodeId !== node.id) {
                  connectNodes(node.id, state.connectHoverNodeId);
                }
                state.connectDrag = null;
                state.connectHoverNodeId = null;
                state.connectFromId = null;
                renderNodes();
              };
              window.addEventListener("pointermove", onMove);
              window.addEventListener("pointerup", onUp);
              return;
            }

            event.preventDefault();
            state.draggingNodeId = node.id;
            const start = canvasPointFromClient(event.clientX, event.clientY);
            const origin = { ...state.uiPositions[node.id] };
            let dragged = false;
            const onMove = (moveEvent) => {
              const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);
              const dx = current.x - start.x;
              const dy = current.y - start.y;
              if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                dragged = true;
              }
              state.uiPositions[node.id] = {
                x: Math.max(8, origin.x + dx),
                y: Math.max(8, origin.y + dy)
              };
              renderNodes();
            };
            const onUp = () => {
              window.removeEventListener("pointermove", onMove);
              window.removeEventListener("pointerup", onUp);
              state.draggingNodeId = null;
              if (dragged) {
                persistDraft();
              } else {
                selectNode(node.id);
              }
              renderNodes();
            };
            window.addEventListener("pointermove", onMove);
            window.addEventListener("pointerup", onUp);
          };
          content.appendChild(div);
        }
      }

      function setFieldVisible(element, visible) {
        element.classList.toggle("hidden", !visible);
      }

      function updateNodeFormByType(node) {
        const isScene = node?.type === "scene";
        const isChoice = node?.type === "choice";
        const isEnding = node?.type === "ending";
        el.nodeTextLabel.textContent = isChoice ? "Choice Prompt" : isEnding ? "Ending Title" : "Node Text";
        setFieldVisible(el.nodeSpeakerField, isScene);
        setFieldVisible(el.nodeTextSpeedField, isScene);
        setFieldVisible(el.nodeNextField, isScene);
        setFieldVisible(el.choiceOptionsField, isChoice);
      }

      function renderChoiceOptionsEditor(node) {
        el.choiceOptionsEditor.innerHTML = "";
        const options = Array.isArray(node?.data?.options) ? node.data.options : [];
        if (options.length === 0) {
          const empty = document.createElement("div");
          empty.className = "mono";
          empty.textContent = "No options yet. Add one.";
          el.choiceOptionsEditor.appendChild(empty);
          return;
        }

        options.forEach((option, index) => {
          const row = document.createElement("div");
          row.className = "choice-option-row";
          row.dataset.optionId = option?.id || `opt_${index + 1}`;
          const labelInput = document.createElement("input");
          labelInput.placeholder = `옵션명 ${index + 1}`;
          labelInput.value = option?.label || "";
          labelInput.dataset.field = "label";
          const toInput = document.createElement("input");
          toInput.placeholder = "target node id";
          toInput.value = option?.to || "";
          toInput.dataset.field = "to";
          const removeButton = document.createElement("button");
          removeButton.textContent = "Remove";
          removeButton.className = "warn";
          removeButton.onclick = () => {
            row.remove();
            if (el.choiceOptionsEditor.children.length === 0) {
              renderChoiceOptionsEditor({ data: { options: [] } });
            }
            applyNodeChanges({ silent: true });
          };
          row.appendChild(labelInput);
          row.appendChild(toInput);
          row.appendChild(removeButton);
          el.choiceOptionsEditor.appendChild(row);
        });
      }

      function readChoiceOptionsFromEditor() {
        const rows = [...el.choiceOptionsEditor.querySelectorAll(".choice-option-row")];
        const options = [];
        rows.forEach((row, index) => {
          const label = (row.querySelector("[data-field='label']")?.value || "").trim();
          const to = (row.querySelector("[data-field='to']")?.value || "").trim();
          if (!label && !to) {
            return;
          }
          options.push({
            id: row.dataset.optionId || `opt_${index + 1}`,
            label: label || `선택 ${index + 1}`,
            to: to || null
          });
        });
        return options.slice(0, 8);
      }

      function selectNode(id) {
        state.selectedNodeId = id;
        const node = state.scenario.nodes.find((n) => n.id === id);
        if (!node) return;
        updateNodeFormByType(node);
        el.selectedNodeLabel.textContent = `${node.id} (${node.type})`;
        if (node.type === "choice") {
          el.nodeText.value = node.data?.prompt ?? "";
          el.nodeSpeaker.value = "";
          el.nodeTextSpeed.value = "";
          el.nodeNext.value = "";
          renderChoiceOptionsEditor(node);
        } else {
          el.nodeText.value = node.type === "ending" ? (node.data?.title ?? "") : (node.data?.text ?? "");
          el.nodeSpeaker.value = node.data?.speaker ?? "";
          el.nodeTextSpeed.value = Number.isFinite(Number(node.data?.textSpeed)) ? String(Math.round(Number(node.data?.textSpeed))) : "";
          el.nodeNext.value = node.next ?? node.data?.to ?? "";
          renderChoiceOptionsEditor({ data: { options: [] } });
        }
        el.nodeBackground.value = node.data?.background ?? "";
        el.nodeCharacterImage.value = node.data?.characterImage ?? "";
        el.nodeMusic.value = node.data?.music ?? "";
        renderNodes();
      }

      function applyNodeChanges(options = {}) {
        const { silent = true } = options;
        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);
        if (!node) return;
        node.data = node.data || {};
        const speaker = (el.nodeSpeaker.value || "").trim();
        const textSpeedInput = (el.nodeTextSpeed.value || "").trim();
        const background = (el.nodeBackground.value || "").trim();
        const characterImage = (el.nodeCharacterImage.value || "").trim();
        const music = (el.nodeMusic.value || "").trim();
        if (node.type === "scene") {
          node.data.text = el.nodeText.value;
          node.next = el.nodeNext.value || null;
          if (speaker) {
            node.data.speaker = speaker;
          } else {
            delete node.data.speaker;
          }
          if (textSpeedInput === "") {
            delete node.data.textSpeed;
          } else {
            const rawSpeed = Number(textSpeedInput);
            if (Number.isFinite(rawSpeed)) {
              node.data.textSpeed = Math.max(0, Math.min(96, Math.round(rawSpeed)));
            }
          }
          delete node.data.prompt;
          delete node.data.options;
        } else if (node.type === "jump") {
          node.data.to = el.nodeNext.value || null;
          delete node.data.textSpeed;
        } else if (node.type === "ending") {
          node.data.title = el.nodeText.value || node.data.title || "Ending";
          delete node.data.textSpeed;
          delete node.data.prompt;
          delete node.data.options;
        } else if (node.type === "choice") {
          node.data.prompt = el.nodeText.value || "선택";
          node.data.options = readChoiceOptionsFromEditor();
          delete node.next;
          delete node.data.text;
          delete node.data.speaker;
          delete node.data.textSpeed;
        } else {
          delete node.data.textSpeed;
        }
        if (background) {
          node.data.background = background;
        } else {
          delete node.data.background;
        }
        if (characterImage) {
          node.data.characterImage = characterImage;
        } else {
          delete node.data.characterImage;
        }
        if (music) {
          node.data.music = music;
        } else {
          delete node.data.music;
        }
        renderNodes();
        persistDraft();
        if (!silent) {
          log(`Applied changes to ${node.id}`);
        }
      }

      function deleteSelectedNode() {
        if (!state.selectedNodeId) {
          log("No selected node to delete.", true);
          return;
        }
        if (state.scenario.nodes.length <= 1) {
          log("Cannot delete the last node.", true);
          return;
        }

        const removeId = state.selectedNodeId;
        state.scenario.nodes = state.scenario.nodes.filter((n) => n.id !== removeId);
        delete state.uiPositions[removeId];
        if (state.connectFromId === removeId) {
          state.connectFromId = null;
        }

        for (const node of state.scenario.nodes) {
          if (node.type === "scene" && node.next === removeId) {
            node.next = null;
          }
          if (node.type === "jump" && node.data?.to === removeId) {
            node.data.to = null;
          }
          if (node.type === "choice" && Array.isArray(node.data?.options)) {
            node.data.options = node.data.options.filter((o) => o.to !== removeId);
          }
          if (node.type === "condition" && Array.isArray(node.data?.branches)) {
            node.data.branches = node.data.branches.filter((b) => b.to !== removeId);
          }
        }

        if (state.scenario.entryNodeId === removeId) {
          state.scenario.entryNodeId = state.scenario.nodes[0]?.id ?? null;
        }
        state.selectedNodeId = state.scenario.entryNodeId ?? state.scenario.nodes[0]?.id ?? null;
        renderNodes();
        if (state.selectedNodeId) {
          selectNode(state.selectedNodeId);
        }
        persistDraft();
        log(`Deleted node ${removeId}`);
      }

      function addNode(type) {
        const id = `n_${type}_${Math.random().toString(36).slice(2, 6)}`;
        const node = { id, type, data: {} };
        if (type === "scene") {
          node.data.text = "새 장면";
          node.data.textSpeed = 24;
          node.next = null;
        }
        if (type === "choice") {
          node.data.prompt = "선택지를 고르세요";
          node.data.options = [{ id: "opt_1", label: "선택 1", to: "n_end" }];
        }
        if (type === "ending") {
          node.data.endingId = id;
          node.data.title = "새 엔딩";
        }
        state.scenario.nodes.push(node);
        renderNodes();
        selectNode(id);
        persistDraft();
      }

      el.addChoiceOption.onclick = () => {
        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);
        if (!node || node.type !== "choice") {
          log("Select a choice node first.", true);
          return;
        }
        const currentRows = el.choiceOptionsEditor.querySelectorAll(".choice-option-row").length;
        if (currentRows >= 8) {
          log("Choice options are limited to 8.", true);
          return;
        }
        if (el.choiceOptionsEditor.querySelector(".choice-option-row") === null) {
          el.choiceOptionsEditor.innerHTML = "";
        }
        const row = document.createElement("div");
        row.className = "choice-option-row";
        row.dataset.optionId = `opt_${currentRows + 1}`;
        row.innerHTML = `
          <input data-field="label" placeholder="옵션명 ${currentRows + 1}" />
          <input data-field="to" placeholder="target node id" />
          <button class="warn">Remove</button>
        `;
        row.querySelector("button").onclick = () => {
          row.remove();
          if (el.choiceOptionsEditor.children.length === 0) {
            renderChoiceOptionsEditor({ data: { options: [] } });
          }
          applyNodeChanges({ silent: true });
        };
        el.choiceOptionsEditor.appendChild(row);
        applyNodeChanges({ silent: true });
      };

      async function createProject() {
        const res = await fetch("/api/projects", {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({
            name: el.projectName.value,
            slug: el.projectSlug.value
          })
        });
        const body = await res.json();
        if (res.ok) {
          state.projectId = body.project?.id || state.projectId;
          el.projectStatus.textContent = `project: ${body.project?.id ?? "created"} (${body.correlationId})`;
          persistDraft();
          log("Project created.");
        } else {
          el.projectStatus.textContent = `${body.code}: ${body.message}`;
          log(`${body.code} ${body.message}`, true);
        }
      }

      async function saveScenario(options = {}) {
        const { silent = false } = options;
        const res = await fetch(`/api/projects/${state.projectId}/scenario`, {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({
            requestedVersion: state.scenarioVersion,
            currentVersion: state.scenarioVersion,
            content: state.scenario
          })
        });
        const body = await res.json();
        if (res.ok) {
          state.scenarioVersion = body.nextVersion;
          persistDraft();
          if (!silent) {
            log(`Scenario saved. version=${state.scenarioVersion}`);
          }
          return true;
        } else {
          if (!silent) {
            log(`${body.code} ${body.message}`, true);
          }
          return false;
        }
      }

      async function validateScenario() {
        const res = await fetch(`/api/projects/${state.projectId}/validate`, {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({ scenario: state.scenario })
        });
        const body = await res.json();
        const issues = body.issues || body.details?.errors || [];
        el.issues.innerHTML = "";
        el.issueCount.textContent = String(issues.length);
        issues.forEach((issue) => {
          const div = document.createElement("div");
          div.className = "issue";
          div.innerHTML = `<strong>${issue.code}</strong> ${issue.message}`;
          el.issues.appendChild(div);
        });
        if (res.ok) {
          log("Validation passed.");
        } else {
          log(`${body.code} (${issues.length} issues)`, true);
        }
      }

      async function buildSeo() {
        const res = await fetch(`/api/projects/${state.projectId}/build`, {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({ jobType: "seo" })
        });
        const body = await res.json();
        if (res.ok) {
          log(`Build queued (${body.jobType})`);
        } else {
          log(`${body.code}: ${body.message}`, true);
        }
      }

      async function openPlayer() {
        const projectRef = state.projectId || el.projectSlug.value?.trim();
        if (!projectRef) {
          log("No project id/slug available for player test.", true);
          return;
        }
        const saved = await saveScenario({ silent: true });
        if (!saved) {
          log("Play Test aborted: scenario save failed.", true);
          return;
        }
        const target = `${playerBaseUrl}/play/${encodeURIComponent(projectRef)}`;
        window.open(target, "_blank", "noopener,noreferrer");
        log(`Opened player test: ${projectRef}`);
      }

      function toggleConnectMode() {
        log("Drag the green handle on a node and drop it on target node to connect.");
      }

      el.createProjectBtn.onclick = createProject;
      el.addScene.onclick = () => addNode("scene");
      el.addChoice.onclick = () => addNode("choice");
      el.addEnding.onclick = () => addNode("ending");
      el.saveScenario.onclick = saveScenario;
      el.validateScenario.onclick = validateScenario;
      el.connectNode.onclick = toggleConnectMode;
      el.buildSeo.onclick = buildSeo;
      el.openPlayer.onclick = openPlayer;
      el.deleteNode.onclick = deleteSelectedNode;
      el.projectName.addEventListener("change", persistDraft);
      el.projectSlug.addEventListener("change", persistDraft);
      [el.nodeText, el.nodeSpeaker, el.nodeTextSpeed, el.nodeNext, el.nodeBackground, el.nodeCharacterImage, el.nodeMusic].forEach((input) => {
        input.addEventListener("input", () => applyNodeChanges({ silent: true }));
      });
      el.choiceOptionsEditor.addEventListener("input", () => applyNodeChanges({ silent: true }));

      restoreDraft();
      renderNodes();
      selectNode(state.scenario.entryNodeId || "n_start");
    </script>
  </body>
</html>
