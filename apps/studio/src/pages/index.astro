---
const defaultScenario = {
  meta: { schemaVersion: "1.0.0", title: "New VN" },
  entryNodeId: "n_start",
  nodes: [
    { id: "n_start", type: "scene", next: "n_end", data: { text: "첫 장면입니다." } },
    { id: "n_end", type: "scene", next: null, data: { text: "마지막 장면입니다." } }
  ]
};
const playerBaseUrl = import.meta.env.PUBLIC_PLAYER_BASE_URL ?? "http://localhost:4322";
---

<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VN Studio</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap");

      :root {
        --bg-top: #292247;
        --bg-bottom: #151225;
        --panel: #251f44;
        --panel-soft: #2f2860;
        --line: #a8c5ff;
        --line-shadow: #394f84;
        --ink: #eef5ff;
        --muted: #9fb0d1;
        --accent: #50e2b7;
        --accent-2: #ffcb61;
        --danger: #ff7697;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--ink);
        font-family: "VT323", monospace;
        font-size: 28px;
        background:
          radial-gradient(circle at 8% 12%, #4b3f90 0, transparent 40%),
          radial-gradient(circle at 90% 88%, #3a3f9a 0, transparent 35%),
          linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
      }

      .layout {
        display: grid;
        grid-template-columns: 290px 1fr 340px;
        height: 100vh;
        gap: 12px;
        padding: 12px;
        overflow: hidden;
      }

      .panel {
        border: 3px solid var(--line);
        box-shadow:
          0 0 0 3px var(--line-shadow),
          0 10px 0 rgba(0, 0, 0, 0.2);
        background: linear-gradient(180deg, var(--panel-soft), var(--panel));
        padding: 12px;
        display: grid;
        gap: 10px;
        align-content: start;
        min-height: 0;
        overflow: auto;
      }

      .editor-panel {
        grid-template-rows: auto 1fr;
        overflow: hidden;
      }

      .panel-sticky {
        position: sticky;
        top: 0;
        z-index: 4;
        background: linear-gradient(180deg, var(--panel-soft), var(--panel));
        padding-bottom: 8px;
      }

      h1,
      h2,
      h3 {
        margin: 0;
      }

      h1,
      h2 {
        font-family: "Press Start 2P", monospace;
        font-size: 13px;
        letter-spacing: 0.04em;
        text-shadow: 2px 2px 0 #000;
      }

      h3 {
        font-size: 22px;
        color: var(--muted);
      }

      .stack {
        display: grid;
        gap: 8px;
      }

      .group {
        border: 2px solid rgba(168, 197, 255, 0.45);
        background: rgba(13, 18, 39, 0.35);
        padding: 10px;
      }

      label {
        display: grid;
        gap: 6px;
        color: #dce8ff;
      }

      .asset-upload-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px;
        align-items: center;
      }

      .asset-upload-row button {
        width: auto;
        min-width: 108px;
      }

      input,
      select,
      textarea,
      button {
        width: 100%;
        border: 2px solid #dce9ff;
        background: #ecf5ff;
        color: #1e2a45;
        font: inherit;
        font-size: 24px;
        padding: 8px 10px;
      }

      textarea {
        resize: vertical;
        min-height: 112px;
      }

      button {
        cursor: pointer;
        background: linear-gradient(180deg, #5a80c9, #43619c);
        color: #f7fbff;
        transition: transform 120ms steps(2), filter 120ms steps(2);
      }

      button:hover {
        transform: translate(-1px, -1px);
        filter: brightness(1.08);
      }

      .primary {
        background: linear-gradient(180deg, #3ed2a2, #289172);
      }

      .warn {
        background: linear-gradient(180deg, #ff8f7d, #d26155);
      }

      .canvas {
        min-height: 420px;
        border: 2px dashed rgba(168, 197, 255, 0.6);
        background:
          linear-gradient(rgba(255, 255, 255, 0.06) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.06) 1px, transparent 1px),
          rgba(13, 17, 34, 0.35);
        background-size: 22px 22px;
        position: relative;
        height: 100%;
        overflow: auto;
      }

      .canvas-content {
        position: relative;
        min-width: 100%;
        min-height: 100%;
      }

      :global(.marquee-select) {
        position: absolute;
        border: 2px dashed #50e2b7;
        background: rgba(80, 226, 183, 0.28);
        box-shadow: 0 0 0 1px rgba(12, 20, 34, 0.9) inset;
        pointer-events: none;
        z-index: 6;
      }

      :global(.node) {
        position: absolute;
        width: 220px;
        border: 2px solid #cfe1ff;
        box-shadow: inset 0 0 0 2px #405b93;
        background: linear-gradient(180deg, #3b3368, #2f2857);
        color: var(--ink);
        text-align: left;
        user-select: none;
        z-index: 2;
        cursor: grab;
        touch-action: none;
        padding: 10px;
        font-family: "VT323", monospace;
        font-size: 24px;
      }

      :global(.node.dragging) {
        cursor: grabbing;
      }

      :global(.node.connect-target) {
        border-color: #50e2b7;
        box-shadow:
          inset 0 0 0 2px #1f6e5b,
          0 0 0 2px rgba(80, 226, 183, 0.4);
      }

      :global(.node.asset-drop-target) {
        border-color: #50e2b7;
        box-shadow:
          inset 0 0 0 2px #1f6e5b,
          0 0 0 3px rgba(80, 226, 183, 0.45);
      }

      :global(.node.asset-node) {
        border-style: dashed;
        border-color: #62e5c0;
        box-shadow: inset 0 0 0 2px #2f8a73;
        background: linear-gradient(180deg, #1f5b56, #19453f);
      }

      :global(.node.selected) {
        border-color: var(--accent-2);
        box-shadow:
          inset 0 0 0 2px #8d6a2b,
          0 0 0 2px rgba(255, 203, 97, 0.35);
      }

      :global(.node-meta) {
        display: flex;
        justify-content: space-between;
        color: var(--accent);
        font-family: "Press Start 2P", monospace;
        font-size: 10px;
        margin-bottom: 6px;
      }

      :global(.node-text) {
        color: #eff5ff;
      }

      :global(.node-row) {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      :global(.connect-handle) {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        border: 2px solid #dce9ff;
        background: #50e2b7;
        flex-shrink: 0;
        cursor: crosshair;
      }

      :global(.edge-layer) {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      :global(.edge-line) {
        stroke: rgba(168, 197, 255, 0.85);
        stroke-width: 2;
      }

      :global(.edge-line-asset) {
        stroke: rgba(80, 226, 183, 0.95);
        stroke-width: 2;
        stroke-dasharray: 4 3;
      }

      :global(.edge-label) {
        fill: #ffcb61;
        font-size: 10px;
        font-family: "Press Start 2P", monospace;
      }

      :global(.edge-label-asset) {
        fill: #50e2b7;
        font-size: 10px;
        font-family: "Press Start 2P", monospace;
      }

      .mono {
        font-family: "Press Start 2P", monospace;
        font-size: 10px;
      }

      .badge {
        display: inline-block;
        min-width: 38px;
        text-align: center;
        border: 2px solid #dce9ff;
        background: #3f66a7;
        color: #f3f8ff;
        padding: 2px 8px;
      }

      .issues {
        max-height: 230px;
        overflow: auto;
        border: 2px solid rgba(168, 197, 255, 0.5);
        background: rgba(16, 20, 42, 0.55);
        padding: 8px;
      }

      .issue {
        padding: 6px 0;
        border-bottom: 1px dashed rgba(168, 197, 255, 0.35);
      }

      .error {
        color: var(--danger);
      }

      .ok {
        color: var(--accent);
      }

      .hidden {
        display: none !important;
      }

      .choice-options {
        display: grid;
        gap: 8px;
      }

      .choice-option-row {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 6px;
        align-items: center;
      }

      .choice-option-row button {
        width: auto;
        min-width: 80px;
      }

      .asset-toolbar {
        display: grid;
        grid-template-columns: repeat(3, minmax(80px, 1fr));
        gap: 6px;
      }

      .asset-list {
        display: grid;
        gap: 6px;
        max-height: 220px;
        overflow: auto;
      }

      .asset-card {
        border: 2px solid rgba(168, 197, 255, 0.55);
        background: rgba(16, 20, 42, 0.6);
        padding: 8px;
        cursor: grab;
      }

      .asset-card:active {
        cursor: grabbing;
      }

      .asset-card .meta {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
      }

      .asset-chip {
        border: 1px solid #dce9ff;
        background: #3f66a7;
        color: #f3f8ff;
        padding: 1px 6px;
        font-size: 11px;
      }

      .asset-preview {
        width: 100%;
        max-height: 72px;
        object-fit: cover;
        border: 1px solid rgba(168, 197, 255, 0.45);
      }

      .toolbar {
        display: grid;
        grid-template-columns: repeat(9, minmax(120px, 1fr));
        gap: 8px;
        position: sticky;
        top: 0;
        z-index: 5;
        background: linear-gradient(180deg, var(--panel-soft), var(--panel));
        padding-bottom: 8px;
      }

      .divider {
        border: 0;
        border-top: 2px solid rgba(168, 197, 255, 0.35);
        margin: 0;
      }

      @media (max-width: 1200px) {
        .layout {
          grid-template-columns: 1fr;
          height: auto;
          overflow: visible;
        }

        .toolbar {
          position: static;
          grid-template-columns: repeat(3, minmax(120px, 1fr));
        }

        .panel {
          overflow: visible;
        }
      }

      @media (max-width: 720px) {
        body {
          font-size: 24px;
        }

        .toolbar {
          grid-template-columns: 1fr 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="layout">
      <section class="panel">
        <div class="panel-sticky">
          <h1>PIXEL VN STUDIO</h1>
          <h3>Project + Scenario Authoring</h3>
        </div>

        <div class="group stack">
          <label>Project Name <input id="projectName" value="My VN" /></label>
          <label>Project Slug <input id="projectSlug" value="my-vn" /></label>
          <button class="primary" id="createProjectBtn">Create Project</button>
          <div id="projectStatus" class="mono"></div>
        </div>

        <hr class="divider" />

        <div class="group stack">
          <h2>ACTOR CONTEXT</h2>
          <label>Role
            <select id="role">
              <option value="owner">owner</option>
              <option value="editor" selected>editor</option>
              <option value="viewer">viewer</option>
            </select>
          </label>
          <label>Plan
            <select id="plan">
              <option value="free" selected>free</option>
              <option value="pro">pro</option>
            </select>
          </label>
          <label>User ID <input id="userId" value="00000000-0000-0000-0000-000000000010" /></label>
          <label>Org ID <input id="orgId" value="00000000-0000-0000-0000-000000000020" /></label>
        </div>
      </section>

      <section class="panel editor-panel">
        <div class="toolbar">
          <button id="addScene">+ Scene</button>
          <button id="addAsset">+ Asset</button>
          <button id="autoLayout">Auto Layout</button>
          <button id="saveScenario" class="primary">Save Scenario</button>
          <button id="validateScenario">Validate</button>
          <button id="connectNode">Connect (Drag)</button>
          <button id="buildSeo" class="warn">Build SEO</button>
          <button id="openPlayer">Play Test</button>
        </div>
        <div class="canvas" id="nodeCanvas"></div>
      </section>

      <aside class="panel">
        <div class="panel-sticky">
          <h2>NODE PROPERTIES</h2>
          <h3 id="selectedNodeLabel">No node selected</h3>
        </div>

        <div class="group stack">
          <label id="nodeTextField"><span id="nodeTextLabel">Node Text</span>
            <textarea id="nodeText" rows="5" placeholder="scene text"></textarea>
          </label>
          <label id="nodeSpeakerField"><span>Character Name</span>
            <input id="nodeSpeaker" placeholder="Narrator" />
          </label>
          <label id="nodeTextSpeedField"><span>Text Speed (ms, 0 = instant)</span>
            <input id="nodeTextSpeed" type="number" min="0" max="96" step="1" placeholder="24" />
          </label>
          <label id="nodeNextField"><span>Next Node ID</span>
            <input id="nodeNext" placeholder="n_end" />
          </label>
          <label id="assetKindField"><span>Asset Kind</span>
            <select id="assetKind">
              <option value="background">background</option>
              <option value="character">character</option>
              <option value="music">music</option>
            </select>
          </label>
          <label id="assetLabelField"><span>Asset Label</span>
            <input id="assetLabel" placeholder="asset label" />
          </label>
          <label id="assetUrlField"><span>Asset URL</span>
            <input id="assetUrl" placeholder="/api/assets/.../file.png" />
          </label>
          <button id="assetUpload" type="button">에셋 업로드</button>
          <button id="applyAssetToLastScene" type="button">선택 씬 일괄 적용</button>
          <input id="assetUploadFile" type="file" accept="image/*,audio/*" class="hidden" />
          <label>Background URL
            <input id="nodeBackground" placeholder="/assets/bg/school.jpg" />
          </label>
          <label>Character Left URL
            <input id="nodeCharacterLeft" placeholder="/assets/char/left.png" />
          </label>
          <label>Character Center URL
            <input id="nodeCharacterCenter" placeholder="/assets/char/center.png" />
          </label>
          <label>Character Right URL
            <input id="nodeCharacterRight" placeholder="/assets/char/right.png" />
          </label>
          <label>BGM URL
            <input id="nodeMusic" placeholder="/assets/bgm/theme.mp3" />
          </label>
          <button id="deleteNode" class="warn">Delete Node</button>
        </div>

        <hr class="divider" />

        <div class="stack">
          <h2>VALIDATION ISSUES <span id="issueCount" class="badge">0</span></h2>
          <div id="issues" class="issues"></div>
        </div>

        <hr class="divider" />

        <div class="stack">
          <h2>ACTIVITY</h2>
          <div id="activity" class="mono"></div>
        </div>
      </aside>
    </main>

    <script type="module" define:vars={{ defaultScenario, playerBaseUrl }}>
      const state = {
        projectId: "p1",
        scenarioVersion: 1,
        selectedNodeId: null,
        connectFromId: null,
        draggingNodeId: null,
        connectDrag: null,
        connectHoverNodeId: null,
        scenario: structuredClone(defaultScenario),
        uiPositions: {},
        lastSelectedSceneId: null,
        multiSelectedSceneIds: [],
        marquee: null,
        assetDropNodeId: null,
        autosaveTimer: null,
        autosaveDirty: false,
        autosaveInFlight: false,
        autosaveQueued: false,
        autosaveHadError: false
      };

      const el = {
        projectName: document.getElementById("projectName"),
        projectSlug: document.getElementById("projectSlug"),
        createProjectBtn: document.getElementById("createProjectBtn"),
        projectStatus: document.getElementById("projectStatus"),
        role: document.getElementById("role"),
        plan: document.getElementById("plan"),
        userId: document.getElementById("userId"),
        orgId: document.getElementById("orgId"),
        nodeCanvas: document.getElementById("nodeCanvas"),
        selectedNodeLabel: document.getElementById("selectedNodeLabel"),
        nodeTextField: document.getElementById("nodeTextField"),
        nodeTextLabel: document.getElementById("nodeTextLabel"),
        nodeText: document.getElementById("nodeText"),
        nodeSpeakerField: document.getElementById("nodeSpeakerField"),
        nodeSpeaker: document.getElementById("nodeSpeaker"),
        nodeTextSpeedField: document.getElementById("nodeTextSpeedField"),
        nodeTextSpeed: document.getElementById("nodeTextSpeed"),
        nodeNextField: document.getElementById("nodeNextField"),
        nodeNext: document.getElementById("nodeNext"),
        assetKindField: document.getElementById("assetKindField"),
        assetKind: document.getElementById("assetKind"),
        assetLabelField: document.getElementById("assetLabelField"),
        assetLabel: document.getElementById("assetLabel"),
        assetUrlField: document.getElementById("assetUrlField"),
        assetUrl: document.getElementById("assetUrl"),
        assetUpload: document.getElementById("assetUpload"),
        applyAssetToLastScene: document.getElementById("applyAssetToLastScene"),
        assetUploadFile: document.getElementById("assetUploadFile"),
        nodeBackground: document.getElementById("nodeBackground"),
        nodeCharacterLeft: document.getElementById("nodeCharacterLeft"),
        nodeCharacterCenter: document.getElementById("nodeCharacterCenter"),
        nodeCharacterRight: document.getElementById("nodeCharacterRight"),
        nodeMusic: document.getElementById("nodeMusic"),
        deleteNode: document.getElementById("deleteNode"),
        addScene: document.getElementById("addScene"),
        addAsset: document.getElementById("addAsset"),
        autoLayout: document.getElementById("autoLayout"),
        saveScenario: document.getElementById("saveScenario"),
        validateScenario: document.getElementById("validateScenario"),
        connectNode: document.getElementById("connectNode"),
        buildSeo: document.getElementById("buildSeo"),
        openPlayer: document.getElementById("openPlayer"),
        issues: document.getElementById("issues"),
        issueCount: document.getElementById("issueCount"),
        activity: document.getElementById("activity")
      };

      function headers(options = {}) {
        const { json = true } = options;
        const base = {
          "x-user-role": el.role.value,
          "x-plan-tier": el.plan.value,
          "x-user-id": el.userId.value,
          "x-org-id": el.orgId.value
        };
        if (json) {
          base["content-type"] = "application/json";
        }
        return base;
      }

      function draftKey() {
        const ref = state.projectId || el.projectSlug.value || "default";
        return `vn.studio.draft.${ref}`;
      }

      function persistDraft() {
        const snapshot = {
          projectId: state.projectId,
          scenarioVersion: state.scenarioVersion,
          scenario: state.scenario,
          uiPositions: state.uiPositions,
          projectName: el.projectName.value,
          projectSlug: el.projectSlug.value
        };
        localStorage.setItem(draftKey(), JSON.stringify(snapshot));
      }

      function restoreDraft() {
        const currentRef = state.projectId || el.projectSlug.value;
        if (!currentRef) {
          return;
        }
        const raw = localStorage.getItem(`vn.studio.draft.${currentRef}`);
        if (!raw) {
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          if (parsed.projectId) state.projectId = parsed.projectId;
          if (Number.isInteger(parsed.scenarioVersion)) state.scenarioVersion = parsed.scenarioVersion;
          if (parsed.projectName) el.projectName.value = parsed.projectName;
          if (parsed.projectSlug) el.projectSlug.value = parsed.projectSlug;
          if (parsed.scenario?.entryNodeId && Array.isArray(parsed.scenario?.nodes)) {
            state.scenario = parsed.scenario;
            normalizeScenarioNodeTypes();
          }
          if (parsed.uiPositions && typeof parsed.uiPositions === "object") {
            state.uiPositions = parsed.uiPositions;
          }
          log("Draft restored from local storage.");
        } catch (error) {
          log(`Draft restore failed: ${error.message}`, true);
        }
      }

      function log(message, error = false) {
        const line = document.createElement("div");
        line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        line.className = error ? "error" : "ok";
        el.activity.prepend(line);
      }

      function normalizeScenarioNodeTypes() {
        for (const node of state.scenario.nodes || []) {
          node.data = node.data || {};
          if (node.type !== "scene" && node.type !== "asset") {
            const fallbackText = node.data?.text ?? node.data?.prompt ?? node.data?.title ?? "";
            node.type = "scene";
            node.data.text = fallbackText;
            delete node.data.prompt;
            delete node.data.options;
            delete node.data.title;
            delete node.data.endingId;
          }
          if (node.type === "scene") {
            const legacyTargets = Array.isArray(node.data?.options)
              ? node.data.options.map((o) => o?.to).filter(Boolean)
              : [];
            const normalizedTargets = Array.isArray(node.data?.targets) && node.data.targets.length > 0
              ? node.data.targets.filter(Boolean)
              : [node.next, ...legacyTargets].filter(Boolean);
            setSceneTargets(node, normalizedTargets);
            delete node.data.options;
            delete node.data.prompt;
            delete node.data.title;
            delete node.data.endingId;
            const normalizedCharacters = normalizeSceneCharacters(node);
            if (normalizedCharacters.length > 0) {
              setSceneCharacters(node, normalizedCharacters);
              delete node.data.characterImage;
            } else {
              delete node.data.characters;
            }
          }
          if (node.type === "asset") {
            node.data.assetKind = ["background", "character", "music"].includes(node.data.assetKind) ? node.data.assetKind : "background";
            node.data.label = node.data.label || "asset";
            node.data.url = node.data.url || "";
            delete node.next;
          }
        }
      }

      function normalizeCharacterSlot(slot, fallback = "right") {
        return ["left", "center", "right"].includes(slot) ? slot : fallback;
      }

      function normalizeSceneCharacters(node) {
        if (!node || node.type !== "scene") {
          return [];
        }
        const raw = Array.isArray(node.data?.characters) ? node.data.characters : [];
        const normalized = [];
        for (const item of raw) {
          if (!item || typeof item !== "object") {
            continue;
          }
          const image = String(item.image || item.url || "").trim();
          if (!image) {
            continue;
          }
          normalized.push({ slot: normalizeCharacterSlot(item.slot), image });
        }
        if (normalized.length > 0) {
          return normalized;
        }
        const legacy = String(node.data?.characterImage || "").trim();
        if (!legacy) {
          return [];
        }
        return [{ slot: "right", image: legacy }];
      }

      function getSceneCharacters(node) {
        return normalizeSceneCharacters(node);
      }

      function setSceneCharacters(node, characters) {
        if (!node || node.type !== "scene") {
          return;
        }
        const uniqueBySlot = new Map();
        for (const character of characters || []) {
          if (!character?.image) {
            continue;
          }
          uniqueBySlot.set(normalizeCharacterSlot(character.slot), {
            slot: normalizeCharacterSlot(character.slot),
            image: String(character.image).trim()
          });
        }
        const ordered = ["left", "center", "right"]
          .map((slot) => uniqueBySlot.get(slot))
          .filter(Boolean);
        if (ordered.length > 0) {
          node.data.characters = ordered;
        } else {
          delete node.data.characters;
        }
      }

      function findAvailableNodePosition(preferred, ignoreNodeId = null) {
        const nodeWidth = 220;
        const nodeHeight = 130;
        const xStep = 250;
        const yStep = 170;
        const isOccupied = (candidateX, candidateY) => {
          return state.scenario.nodes.some((node) => {
            if (node.id === ignoreNodeId) return false;
            const pos = state.uiPositions[node.id];
            if (!pos) return false;
            const overlapX = Math.abs(pos.x - candidateX) < nodeWidth;
            const overlapY = Math.abs(pos.y - candidateY) < nodeHeight;
            return overlapX && overlapY;
          });
        };

        for (let i = 0; i < 200; i += 1) {
          const col = i % 6;
          const row = Math.floor(i / 6);
          const x = preferred.x + col * xStep;
          const y = preferred.y + row * yStep;
          if (!isOccupied(x, y)) {
            return { x, y };
          }
        }
        return { x: preferred.x, y: preferred.y };
      }

      function markScenarioDirty() {
        state.autosaveDirty = true;
        scheduleAutosave();
      }

      function scheduleAutosave() {
        if (state.autosaveTimer) {
          clearTimeout(state.autosaveTimer);
        }
        state.autosaveTimer = setTimeout(() => {
          state.autosaveTimer = null;
          flushAutosave();
        }, 1200);
      }

      async function flushAutosave() {
        if (!state.autosaveDirty) {
          return;
        }
        if (state.autosaveInFlight) {
          state.autosaveQueued = true;
          return;
        }

        state.autosaveInFlight = true;
        state.autosaveDirty = false;
        const saved = await saveScenario({ silent: true });
        state.autosaveInFlight = false;

        if (saved) {
          if (state.autosaveHadError) {
            log("Auto-save recovered.");
          }
          state.autosaveHadError = false;
        } else {
          state.autosaveDirty = true;
          if (!state.autosaveHadError) {
            log("Auto-save failed. Check project setup/permissions.", true);
          }
          state.autosaveHadError = true;
        }

        if (state.autosaveDirty || state.autosaveQueued) {
          state.autosaveQueued = false;
          scheduleAutosave();
        }
      }

      function currentProjectRef() {
        return state.projectId || (el.projectSlug.value || "").trim() || "default";
      }

      function inferAssetKindFromFile(file) {
        const mime = String(file?.type || "").toLowerCase();
        if (mime.startsWith("audio/")) {
          return "music";
        }
        if (mime.startsWith("image/")) {
          return "background";
        }
        return null;
      }

      async function uploadAssetFile(file, kind) {
        if (!(file instanceof File)) {
          return { ok: false, message: "No file selected." };
        }
        const ref = currentProjectRef();
        const form = new FormData();
        form.set("kind", kind);
        form.set("file", file);
        try {
          const res = await fetch(`/api/projects/${encodeURIComponent(ref)}/assets`, {
            method: "POST",
            headers: headers({ json: false }),
            body: form
          });
          const body = await res.json();
          if (!res.ok || !body?.url) {
            return { ok: false, message: `${body?.code ?? "UPLOAD_FAILED"}: ${body?.message ?? "Asset upload failed."}` };
          }
          return { ok: true, url: body.url };
        } catch (error) {
          return { ok: false, message: `Asset upload failed: ${error.message}` };
        }
      }

      async function uploadSelectedAssetNodeFile(file) {
        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);
        if (!node || node.type !== "asset") {
          log("Select an asset node first.", true);
          return;
        }
        const kind = inferAssetKindFromFile(file);
        if (!kind) {
          log("Only image/audio files are supported.", true);
          return;
        }
        const result = await uploadAssetFile(file, kind);
        if (!result.ok) {
          log(result.message, true);
          return;
        }
        el.assetKind.value = kind;
        el.assetUrl.value = result.url;
        if (!el.assetLabel.value.trim()) {
          el.assetLabel.value = file.name || "asset";
        }
        applyNodeChanges({ silent: true });
        log(`Asset uploaded: ${file.name}`);
      }

      function applyAssetNodeToScene(assetNodeId, sceneNodeId, options = {}) {
        const { silent = false } = options;
        const assetNode = state.scenario.nodes.find((n) => n.id === assetNodeId);
        const sceneNode = state.scenario.nodes.find((n) => n.id === sceneNodeId);
        if (!assetNode || !sceneNode) {
          return;
        }
        if (assetNode.type !== "asset") {
          return;
        }
        if (sceneNode.type !== "scene") {
          log("Asset node can only be dropped on a scene node.", true);
          return;
        }
        const kind = assetNode.data?.assetKind;
        const url = (assetNode.data?.url || "").trim();
        if (!url) {
          log("Asset node has no URL.", true);
          return;
        }

        sceneNode.data = sceneNode.data || {};
        sceneNode.data.assetLinks = sceneNode.data.assetLinks || {};
        if (kind === "background") {
          sceneNode.data.background = url;
          sceneNode.data.assetLinks.background = assetNode.id;
        } else if (kind === "character") {
          const existingCharacters = getSceneCharacters(sceneNode);
          const occupiedSlots = new Set(existingCharacters.map((character) => character.slot));
          const slot = ["left", "center", "right"].find((candidate) => !occupiedSlots.has(candidate)) || "right";
          const nextCharacters = existingCharacters.filter((character) => character.slot !== slot);
          nextCharacters.push({ slot, image: url });
          setSceneCharacters(sceneNode, nextCharacters);
          delete sceneNode.data.characterImage;
          const linkedCharacters = Array.isArray(sceneNode.data.assetLinks.character)
            ? sceneNode.data.assetLinks.character.filter(Boolean)
            : (sceneNode.data.assetLinks.character ? [sceneNode.data.assetLinks.character] : []);
          if (!linkedCharacters.includes(assetNode.id)) {
            linkedCharacters.push(assetNode.id);
          }
          sceneNode.data.assetLinks.character = linkedCharacters;
        } else if (kind === "music") {
          sceneNode.data.music = url;
          sceneNode.data.assetLinks.music = assetNode.id;
        } else {
          log("Unsupported asset kind.", true);
          return;
        }

        if (state.selectedNodeId === sceneNode.id) {
          selectNode(sceneNode.id);
        } else {
          renderNodes();
        }
        persistDraft();
        markScenarioDirty();
        if (!silent) {
          log(`Applied ${kind} asset to ${sceneNode.id}`);
        }
      }

      function applyAssetNodeToScenes(assetNodeId, sceneIds) {
        const uniqueSceneIds = [...new Set((sceneIds || []).filter(Boolean))];
        if (uniqueSceneIds.length === 0) {
          log("적용할 씬이 없습니다.", true);
          return;
        }
        let applied = 0;
        for (const sceneId of uniqueSceneIds) {
          const sceneNode = state.scenario.nodes.find((n) => n.id === sceneId);
          if (!sceneNode || sceneNode.type !== "scene") {
            continue;
          }
          applyAssetNodeToScene(assetNodeId, sceneId, { silent: true });
          applied += 1;
        }
        if (applied === 0) {
          log("선택된 씬에 적용할 수 없습니다.", true);
          return;
        }
        log(`Asset applied to ${applied} scene node(s).`);
      }

      function ensureNodePosition(nodeId, fallbackIndex = 0) {
        if (state.uiPositions[nodeId]) {
          return state.uiPositions[nodeId];
        }
        const preferred = {
          x: 24 + (fallbackIndex % 4) * 250,
          y: 24 + Math.floor(fallbackIndex / 4) * 170
        };
        const position = findAvailableNodePosition(preferred, nodeId);
        state.uiPositions[nodeId] = position;
        return position;
      }

      function getEdgeList() {
        const edges = [];
        for (const node of state.scenario.nodes) {
          if (node.type === "scene") {
            const targets = getSceneTargets(node);
            targets.forEach((to, index) => {
              if (!to) return;
              const label = targets.length >= 2 ? `opt${index + 1}` : "next";
              edges.push({ from: node.id, to, label });
            });
          }
        }
        return edges;
      }

      function autoLayoutNodes() {
        const nodes = state.scenario.nodes || [];
        if (nodes.length === 0) {
          return;
        }

        const adjacency = new Map();
        for (const node of nodes) {
          adjacency.set(node.id, []);
        }
        for (const edge of getEdgeList()) {
          if (!adjacency.has(edge.from)) adjacency.set(edge.from, []);
          adjacency.get(edge.from).push(edge.to);
        }

        const depthById = new Map();
        const rootId = state.scenario.entryNodeId || nodes[0]?.id;
        const queue = [];
        if (rootId) {
          depthById.set(rootId, 0);
          queue.push(rootId);
        }

        while (queue.length > 0) {
          const id = queue.shift();
          const currentDepth = depthById.get(id) ?? 0;
          for (const nextId of adjacency.get(id) || []) {
            if (!depthById.has(nextId)) {
              depthById.set(nextId, currentDepth + 1);
              queue.push(nextId);
            }
          }
        }

        let fallbackDepth = 0;
        for (const node of nodes) {
          if (!depthById.has(node.id)) {
            depthById.set(node.id, fallbackDepth + 1);
            fallbackDepth += 1;
          }
        }

        const lanes = new Map();
        for (const node of nodes) {
          const depth = depthById.get(node.id) ?? 0;
          if (!lanes.has(depth)) lanes.set(depth, []);
          lanes.get(depth).push(node.id);
        }

        const xGap = 280;
        const yGap = 180;
        for (const [depth, ids] of lanes.entries()) {
          ids.forEach((id, rowIndex) => {
            state.uiPositions[id] = {
              x: 24 + depth * xGap,
              y: 24 + rowIndex * yGap
            };
          });
        }

        renderNodes();
        persistDraft();
        log("Auto layout applied.");
      }

      function connectNodes(fromId, toId) {
        const source = state.scenario.nodes.find((n) => n.id === fromId);
        if (!source) {
          return;
        }
        const target = state.scenario.nodes.find((n) => n.id === toId);
        if (!target) {
          return;
        }
        if (source.type !== "scene") {
          log("Only scene nodes can connect to next nodes.", true);
          return;
        }
        if (target.type !== "scene") {
          log("Scene node can only connect to scene node.", true);
          return;
        }
        const targets = getSceneTargets(source);
        if (!targets.includes(toId)) {
          targets.push(toId);
        }
        setSceneTargets(source, targets);
        persistDraft();
        markScenarioDirty();
        if (state.selectedNodeId === source.id) {
          selectNode(source.id);
        } else {
          renderNodes();
        }
        el.connectNode.textContent = "Connect (Drag)";
        log(`Connected ${fromId} -> ${toId}`);
      }

      function canvasPointFromClient(clientX, clientY) {
        const rect = el.nodeCanvas.getBoundingClientRect();
        return {
          x: clientX - rect.left + el.nodeCanvas.scrollLeft,
          y: clientY - rect.top + el.nodeCanvas.scrollTop
        };
      }

      function findNodeIdFromClient(clientX, clientY) {
        const element = document.elementFromPoint(clientX, clientY);
        const nodeEl = element?.closest?.(".node[data-node-id]");
        if (!nodeEl) {
          return null;
        }
        return nodeEl.getAttribute("data-node-id");
      }

      function getSelectedSceneIdsForAssetEdges() {
        if (state.multiSelectedSceneIds.length > 0) {
          return state.multiSelectedSceneIds.filter((id) => state.scenario.nodes.some((n) => n.id === id && n.type === "scene"));
        }
        if (state.selectedNodeId) {
          const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);
          if (node?.type === "scene") {
            return [node.id];
          }
        }
        return [];
      }

      function setMultiSceneSelection(ids) {
        const sceneIds = new Set(
          (ids || []).filter((id) => state.scenario.nodes.some((n) => n.id === id && n.type === "scene"))
        );
        state.multiSelectedSceneIds = [...sceneIds];
      }

      function toggleSceneSelection(id) {
        if (!state.scenario.nodes.some((n) => n.id === id && n.type === "scene")) {
          return;
        }
        const selected = new Set(state.multiSelectedSceneIds);
        if (selected.has(id)) {
          selected.delete(id);
        } else {
          selected.add(id);
        }
        state.multiSelectedSceneIds = [...selected];
      }

      function renderNodes() {
        el.nodeCanvas.innerHTML = "";
        const content = document.createElement("div");
        content.className = "canvas-content";
        el.nodeCanvas.appendChild(content);

        const edgeLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        edgeLayer.setAttribute("class", "edge-layer");
        content.appendChild(edgeLayer);

        state.scenario.nodes.forEach((node, index) => ensureNodePosition(node.id, index));
        const maxX = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.x ?? 0) + 260), 1200);
        const maxY = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.y ?? 0) + 180), 900);
        content.style.width = `${maxX}px`;
        content.style.height = `${maxY}px`;

        for (const edge of getEdgeList()) {
          const fromPos = state.uiPositions[edge.from];
          const toPos = state.uiPositions[edge.to];
          if (!fromPos || !toPos) {
            continue;
          }
          const x1 = fromPos.x + 220;
          const y1 = fromPos.y + 46;
          const x2 = toPos.x;
          const y2 = toPos.y + 46;

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", String(x1));
          line.setAttribute("y1", String(y1));
          line.setAttribute("x2", String(x2));
          line.setAttribute("y2", String(y2));
          line.setAttribute("class", "edge-line");
          edgeLayer.appendChild(line);

          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
          label.setAttribute("x", String((x1 + x2) / 2));
          label.setAttribute("y", String((y1 + y2) / 2 - 4));
          label.setAttribute("class", "edge-label");
          label.textContent = edge.label;
          edgeLayer.appendChild(label);
        }

        const selectedScenesForAssetEdges = getSelectedSceneIdsForAssetEdges();
        for (const sceneId of selectedScenesForAssetEdges) {
          const sceneNode = state.scenario.nodes.find((n) => n.id === sceneId && n.type === "scene");
          if (!sceneNode) continue;
          const links = sceneNode.data?.assetLinks || {};
          for (const [kind, assetNodeId] of Object.entries(links)) {
            const linkedIds = Array.isArray(assetNodeId) ? assetNodeId : [assetNodeId];
            for (const linkedId of linkedIds.filter(Boolean)) {
              const assetNode = state.scenario.nodes.find((n) => n.id === linkedId && n.type === "asset");
              if (!assetNode) continue;
              const fromPos = state.uiPositions[sceneId];
              const toPos = state.uiPositions[linkedId];
              if (!fromPos || !toPos) continue;

              const x1 = fromPos.x + 220;
              const y1 = fromPos.y + 30;
              const x2 = toPos.x;
              const y2 = toPos.y + 30;

              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
              line.setAttribute("x1", String(x1));
              line.setAttribute("y1", String(y1));
              line.setAttribute("x2", String(x2));
              line.setAttribute("y2", String(y2));
              line.setAttribute("class", "edge-line-asset");
              edgeLayer.appendChild(line);

              const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
              label.setAttribute("x", String((x1 + x2) / 2));
              label.setAttribute("y", String((y1 + y2) / 2 - 6));
              label.setAttribute("class", "edge-label-asset");
              label.textContent = `asset:${kind}`;
              edgeLayer.appendChild(label);
            }
          }
        }

        if (state.connectDrag) {
          const fromPos = state.uiPositions[state.connectDrag.fromId];
          if (fromPos) {
            const x1 = fromPos.x + 220;
            const y1 = fromPos.y + 46;
            const x2 = state.connectDrag.x;
            const y2 = state.connectDrag.y;
            const preview = document.createElementNS("http://www.w3.org/2000/svg", "line");
            preview.setAttribute("x1", String(x1));
            preview.setAttribute("y1", String(y1));
            preview.setAttribute("x2", String(x2));
            preview.setAttribute("y2", String(y2));
            preview.setAttribute("class", "edge-line");
            preview.setAttribute("stroke-dasharray", "5 4");
            edgeLayer.appendChild(preview);
          }
        }

        if (state.marquee) {
          const x = Math.min(state.marquee.x1, state.marquee.x2);
          const y = Math.min(state.marquee.y1, state.marquee.y2);
          const w = Math.abs(state.marquee.x2 - state.marquee.x1);
          const h = Math.abs(state.marquee.y2 - state.marquee.y1);
          const box = document.createElement("div");
          box.className = "marquee-select";
          box.style.left = `${x}px`;
          box.style.top = `${y}px`;
          box.style.width = `${w}px`;
          box.style.height = `${h}px`;
          content.appendChild(box);
        }

        for (const node of state.scenario.nodes) {
          const div = document.createElement("div");
          const isMultiSelectedScene = node.type === "scene" && state.multiSelectedSceneIds.includes(node.id);
          const isSelected = state.selectedNodeId === node.id || state.connectFromId === node.id || isMultiSelectedScene;
          const isDragging = state.draggingNodeId === node.id;
          const isConnectTarget = state.connectHoverNodeId === node.id;
          const isAssetDropTarget = state.assetDropNodeId === node.id;
          const nodeTypeClass = node.type === "asset" ? "asset-node" : "scene-node";
          div.className = `node ${nodeTypeClass} ${isSelected ? "selected" : ""} ${isDragging ? "dragging" : ""} ${isConnectTarget ? "connect-target" : ""} ${isAssetDropTarget ? "asset-drop-target" : ""}`;
          div.setAttribute("data-node-id", node.id);
          const pos = state.uiPositions[node.id];
          div.style.left = `${pos.x}px`;
          div.style.top = `${pos.y}px`;
          const sceneTargets = node.type === "scene" ? getSceneTargets(node) : [];
          const sceneState = node.type === "scene"
            ? (sceneTargets.length === 0 ? "ending" : (sceneTargets.length >= 2 ? "option" : "normal"))
            : "-";
          const nodePreview = node.type === "asset"
            ? (node.data?.label || node.data?.url || "(asset)")
            : (node.data?.text || "(no text)");
          const nodeNextDisplay = node.type === "scene" ? (sceneTargets[0] || "-") : "-";
          const nodeAssetDisplay = node.type === "asset"
            ? `${node.data?.assetKind || "-"}:${node.data?.url ? "y" : "-"}`
            : "-";
          div.innerHTML = `
            <div class="node-meta"><span>${node.id}</span><span>${node.type}</span></div>
            <div class="node-text">${nodePreview}</div>
            <div class="node-row">
              <span class="mono">next: ${nodeNextDisplay} / scene:${sceneState} / asset:${nodeAssetDisplay}</span>
              <span class="connect-handle" data-role="connect-handle" title="Drag to connect/apply"></span>
            </div>
            <div class="mono">bg:${node.data?.background ? "y" : "-"} char:${getSceneCharacters(node).length > 0 || node.data?.characterImage ? "y" : "-"} bgm:${node.data?.music ? "y" : "-"} spd:${Number.isFinite(Number(node.data?.textSpeed)) ? Math.round(Number(node.data?.textSpeed)) : "-"}</div>
          `;
          div.onpointerdown = (event) => {
            const isHandle = event.target?.closest?.("[data-role='connect-handle']");
            if (isHandle) {
              event.preventDefault();
              event.stopPropagation();
              state.connectDrag = {
                fromId: node.id,
                ...canvasPointFromClient(event.clientX, event.clientY)
              };
              state.connectHoverNodeId = null;
              state.connectFromId = node.id;
              const onMove = (moveEvent) => {
                state.connectDrag = {
                  fromId: node.id,
                  ...canvasPointFromClient(moveEvent.clientX, moveEvent.clientY)
                };
                const hovered = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);
                state.connectHoverNodeId = hovered && hovered !== node.id ? hovered : null;
                renderNodes();
              };
              const onUp = () => {
                window.removeEventListener("pointermove", onMove);
                window.removeEventListener("pointerup", onUp);
                if (state.connectHoverNodeId && state.connectHoverNodeId !== node.id) {
                  if (node.type === "scene") {
                    connectNodes(node.id, state.connectHoverNodeId);
                  } else if (node.type === "asset") {
                    const selectedScenes = state.multiSelectedSceneIds.length > 0
                      ? state.multiSelectedSceneIds
                      : (state.lastSelectedSceneId ? [state.lastSelectedSceneId] : []);
                    if (selectedScenes.length > 0) {
                      applyAssetNodeToScenes(node.id, selectedScenes);
                    } else {
                      applyAssetNodeToScene(node.id, state.connectHoverNodeId);
                    }
                  }
                }
                state.connectDrag = null;
                state.connectHoverNodeId = null;
                state.connectFromId = null;
                renderNodes();
              };
              window.addEventListener("pointermove", onMove);
              window.addEventListener("pointerup", onUp);
              return;
            }

            event.preventDefault();
            state.draggingNodeId = node.id;
            const start = canvasPointFromClient(event.clientX, event.clientY);
            const origin = { ...state.uiPositions[node.id] };
            const toggleMulti = Boolean(event.ctrlKey || event.metaKey);
            let dragged = false;
            let lastClientX = event.clientX;
            let lastClientY = event.clientY;
            const onMove = (moveEvent) => {
              lastClientX = moveEvent.clientX;
              lastClientY = moveEvent.clientY;
              const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);
              const dx = current.x - start.x;
              const dy = current.y - start.y;
              if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                dragged = true;
              }
              state.uiPositions[node.id] = {
                x: Math.max(8, origin.x + dx),
                y: Math.max(8, origin.y + dy)
              };
              const hoveredNodeId = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);
              state.assetDropNodeId = hoveredNodeId && hoveredNodeId !== node.id ? hoveredNodeId : null;
              renderNodes();
            };
            const onUp = () => {
              window.removeEventListener("pointermove", onMove);
              window.removeEventListener("pointerup", onUp);
              state.draggingNodeId = null;
              state.assetDropNodeId = null;
              if (dragged) {
                persistDraft();
              } else {
                if (node.type !== "scene") {
                  selectNode(node.id, { preserveMulti: true });
                } else if (toggleMulti) {
                  toggleSceneSelection(node.id);
                  selectNode(node.id, { preserveMulti: true });
                } else {
                  selectNode(node.id);
                }
              }
              renderNodes();
            };
            window.addEventListener("pointermove", onMove);
            window.addEventListener("pointerup", onUp);
          };
          content.appendChild(div);
        }

        const startMarqueeSelection = (event) => {
          if (event.target?.closest?.(".node")) {
            return;
          }
          if (event.button !== 0) {
            return;
          }
          event.preventDefault();
          const start = canvasPointFromClient(event.clientX, event.clientY);
          const additive = Boolean(event.ctrlKey || event.metaKey);
          const baseSelection = additive ? new Set(state.multiSelectedSceneIds) : new Set();
          state.marquee = { x1: start.x, y1: start.y, x2: start.x, y2: start.y };
          renderNodes();

          const onMove = (moveEvent) => {
            const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);
            state.marquee = { x1: start.x, y1: start.y, x2: current.x, y2: current.y };
            renderNodes();
          };

          const onUp = () => {
            window.removeEventListener("pointermove", onMove);
            window.removeEventListener("pointerup", onUp);
            const marquee = state.marquee;
            state.marquee = null;
            if (!marquee) {
              renderNodes();
              return;
            }
            const x1 = Math.min(marquee.x1, marquee.x2);
            const y1 = Math.min(marquee.y1, marquee.y2);
            const x2 = Math.max(marquee.x1, marquee.x2);
            const y2 = Math.max(marquee.y1, marquee.y2);
            const isClick = Math.abs(marquee.x2 - marquee.x1) < 4 && Math.abs(marquee.y2 - marquee.y1) < 4;

            if (isClick) {
              if (!additive) {
                setMultiSceneSelection([]);
              }
              renderNodes();
              return;
            }

            const selectedByBox = state.scenario.nodes
              .filter((n) => n.type === "scene")
              .filter((n) => {
                const p = state.uiPositions[n.id];
                if (!p) return false;
                const nx1 = p.x;
                const ny1 = p.y;
                const nx2 = p.x + 220;
                const ny2 = p.y + 130;
                return nx1 <= x2 && nx2 >= x1 && ny1 <= y2 && ny2 >= y1;
              })
              .map((n) => n.id);

            const merged = new Set(baseSelection);
            selectedByBox.forEach((id) => merged.add(id));
            setMultiSceneSelection([...merged]);
            if (state.multiSelectedSceneIds.length === 1) {
              selectNode(state.multiSelectedSceneIds[0], { preserveMulti: true });
            } else {
              renderNodes();
            }
          };

          window.addEventListener("pointermove", onMove);
          window.addEventListener("pointerup", onUp);
        };
        content.onpointerdown = startMarqueeSelection;
        el.nodeCanvas.onpointerdown = startMarqueeSelection;
      }

      function setFieldVisible(element, visible) {
        element.classList.toggle("hidden", !visible);
      }

      function updateNodeFormByType(node) {
        const isScene = node?.type === "scene";
        const isAsset = node?.type === "asset";
        el.nodeTextLabel.textContent = "Node Text";
        setFieldVisible(el.nodeTextField, isScene);
        setFieldVisible(el.nodeSpeakerField, isScene);
        setFieldVisible(el.nodeTextSpeedField, isScene);
        setFieldVisible(el.nodeNextField, false);
        setFieldVisible(el.assetKindField, isAsset);
        setFieldVisible(el.assetLabelField, isAsset);
        setFieldVisible(el.assetUrlField, isAsset);
        setFieldVisible(el.assetUpload, isAsset);
        setFieldVisible(el.applyAssetToLastScene, isAsset);
        setFieldVisible(el.nodeBackground.parentElement, isScene);
        setFieldVisible(el.nodeCharacterLeft.parentElement, isScene);
        setFieldVisible(el.nodeCharacterCenter.parentElement, isScene);
        setFieldVisible(el.nodeCharacterRight.parentElement, isScene);
        setFieldVisible(el.nodeMusic.parentElement, isScene);
      }

      function selectNode(id, options = {}) {
        const { preserveMulti = false } = options;
        state.selectedNodeId = id;
        const node = state.scenario.nodes.find((n) => n.id === id);
        if (!node) return;
        if (!preserveMulti) {
          if (node.type === "scene") {
            setMultiSceneSelection([node.id]);
          } else {
            setMultiSceneSelection([]);
          }
        }
        if (node.type === "scene") {
          state.lastSelectedSceneId = node.id;
        }
        updateNodeFormByType(node);
        el.selectedNodeLabel.textContent = `${node.id} (${node.type})`;
        if (node.type === "asset") {
          el.nodeText.value = "";
          el.nodeSpeaker.value = "";
          el.nodeTextSpeed.value = "";
          el.nodeNext.value = "";
          el.assetKind.value = node.data?.assetKind || "background";
          el.assetLabel.value = node.data?.label || "";
          el.assetUrl.value = node.data?.url || "";
        } else {
          const sceneTargets = getSceneTargets(node);
          el.nodeText.value = node.data?.text ?? "";
          el.nodeSpeaker.value = node.data?.speaker ?? "";
          el.nodeTextSpeed.value = Number.isFinite(Number(node.data?.textSpeed)) ? String(Math.round(Number(node.data?.textSpeed))) : "";
          el.nodeNext.value = sceneTargets[0] ?? "";
          el.assetKind.value = "background";
          el.assetLabel.value = "";
          el.assetUrl.value = "";
        }
        el.nodeBackground.value = node.data?.background ?? "";
        const characters = getSceneCharacters(node);
        el.nodeCharacterLeft.value = characters.find((character) => character.slot === "left")?.image || "";
        el.nodeCharacterCenter.value = characters.find((character) => character.slot === "center")?.image || "";
        el.nodeCharacterRight.value = characters.find((character) => character.slot === "right")?.image || "";
        el.nodeMusic.value = node.data?.music ?? "";
        renderNodes();
      }

      function applySelectedAssetToLastScene() {
        const assetNode = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);
        if (!assetNode || assetNode.type !== "asset") {
          log("Select an asset node first.", true);
          return;
        }
        const selectedScenes = state.multiSelectedSceneIds.length > 0
          ? state.multiSelectedSceneIds
          : (state.lastSelectedSceneId ? [state.lastSelectedSceneId] : []);
        if (selectedScenes.length === 0) {
          log("적용할 씬을 먼저 선택하세요.", true);
          return;
        }
        applyAssetNodeToScenes(assetNode.id, selectedScenes);
      }

      function getSceneTargets(node) {
        if (!node || node.type !== "scene") {
          return [];
        }
        const stored = Array.isArray(node.data?.targets) ? node.data.targets.filter(Boolean) : [];
        if (stored.length > 0) {
          return [...new Set(stored)];
        }
        return node.next ? [node.next] : [];
      }

      function setSceneTargets(node, targets) {
        if (!node || node.type !== "scene") {
          return;
        }
        const unique = [...new Set((targets || []).filter(Boolean))];
        node.data = node.data || {};
        node.data.targets = unique;
        node.next = unique[0] || null;
      }

      function applyNodeChanges(options = {}) {
        const { silent = true } = options;
        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);
        if (!node) return;
        node.data = node.data || {};
        const speaker = (el.nodeSpeaker.value || "").trim();
        const textSpeedInput = (el.nodeTextSpeed.value || "").trim();
        const background = (el.nodeBackground.value || "").trim();
        const characterLeft = (el.nodeCharacterLeft.value || "").trim();
        const characterCenter = (el.nodeCharacterCenter.value || "").trim();
        const characterRight = (el.nodeCharacterRight.value || "").trim();
        const music = (el.nodeMusic.value || "").trim();
        const assetKind = (el.assetKind.value || "background").trim();
        const assetLabel = (el.assetLabel.value || "").trim();
        const assetUrl = (el.assetUrl.value || "").trim();
        if (node.type === "scene") {
          node.data.text = el.nodeText.value;
          const sceneTargets = getSceneTargets(node);
          setSceneTargets(node, sceneTargets);
          if (speaker) {
            node.data.speaker = speaker;
          } else {
            delete node.data.speaker;
          }
          if (textSpeedInput === "") {
            delete node.data.textSpeed;
          } else {
            const rawSpeed = Number(textSpeedInput);
            if (Number.isFinite(rawSpeed)) {
              node.data.textSpeed = Math.max(0, Math.min(96, Math.round(rawSpeed)));
            }
          }
          delete node.data.assetKind;
          delete node.data.label;
          delete node.data.url;
        } else if (node.type === "asset") {
          node.data.assetKind = ["background", "character", "music"].includes(assetKind) ? assetKind : "background";
          node.data.label = assetLabel || "asset";
          node.data.url = assetUrl;
          delete node.next;
          delete node.data.text;
          delete node.data.speaker;
          delete node.data.textSpeed;
          delete node.data.background;
          delete node.data.characters;
          delete node.data.characterImage;
          delete node.data.music;
        } else {
          delete node.data.textSpeed;
        }
        if (node.type === "scene") {
          if (background) {
            node.data.background = background;
          } else {
            delete node.data.background;
          }
          setSceneCharacters(node, [
            { slot: "left", image: characterLeft },
            { slot: "center", image: characterCenter },
            { slot: "right", image: characterRight }
          ]);
          delete node.data.characterImage;
          if (music) {
            node.data.music = music;
          } else {
            delete node.data.music;
          }
        }
        renderNodes();
        persistDraft();
        markScenarioDirty();
        if (!silent) {
          log(`Applied changes to ${node.id}`);
        }
      }

      function deleteSelectedNode() {
        if (!state.selectedNodeId) {
          log("No selected node to delete.", true);
          return;
        }
        if (state.scenario.nodes.length <= 1) {
          log("Cannot delete the last node.", true);
          return;
        }

        const removeId = state.selectedNodeId;
        state.scenario.nodes = state.scenario.nodes.filter((n) => n.id !== removeId);
        delete state.uiPositions[removeId];
        if (state.connectFromId === removeId) {
          state.connectFromId = null;
        }

        for (const node of state.scenario.nodes) {
          if (node.type === "scene") {
            const targets = getSceneTargets(node).filter((id) => id !== removeId);
            setSceneTargets(node, targets);
            if (node.data?.assetLinks && typeof node.data.assetLinks === "object") {
              for (const [kind, linkedId] of Object.entries(node.data.assetLinks)) {
                if (linkedId === removeId) {
                  delete node.data.assetLinks[kind];
                } else if (Array.isArray(linkedId)) {
                  const filtered = linkedId.filter((id) => id !== removeId);
                  if (filtered.length > 0) {
                    node.data.assetLinks[kind] = filtered;
                  } else {
                    delete node.data.assetLinks[kind];
                  }
                }
              }
            }
          }
        }

        if (state.scenario.entryNodeId === removeId) {
          state.scenario.entryNodeId = state.scenario.nodes[0]?.id ?? null;
        }
        state.selectedNodeId = state.scenario.entryNodeId ?? state.scenario.nodes[0]?.id ?? null;
        renderNodes();
        if (state.selectedNodeId) {
          selectNode(state.selectedNodeId);
        }
        persistDraft();
        markScenarioDirty();
        log(`Deleted node ${removeId}`);
      }

      function addNode(type, payload = null) {
        const id = `n_${type}_${Math.random().toString(36).slice(2, 6)}`;
        const node = { id, type, data: {} };
        let previousLinkedTargetId = null;
        if (type === "scene") {
          node.data.text = "새 장면";
          node.data.textSpeed = 24;
          setSceneTargets(node, []);
        }
        if (type === "asset") {
          node.data.assetKind = payload?.assetKind || "background";
          node.data.label = payload?.label || "asset";
          node.data.url = payload?.url || "";
        }
        const selectedIndex = state.scenario.nodes.findIndex((n) => n.id === state.selectedNodeId);
        const selectedNode = selectedIndex >= 0 ? state.scenario.nodes[selectedIndex] : null;

        if (type === "scene" && selectedNode) {
          state.scenario.nodes.splice(selectedIndex + 1, 0, node);
          if (selectedNode.type === "scene") {
            const selectedTargets = getSceneTargets(selectedNode);
            previousLinkedTargetId = selectedTargets[0] ?? null;
            const restTargets = selectedTargets.slice(1);
            setSceneTargets(selectedNode, [id, ...restTargets]);
            setSceneTargets(node, previousLinkedTargetId ? [previousLinkedTargetId] : []);
          }
        } else if (selectedNode) {
          state.scenario.nodes.splice(selectedIndex + 1, 0, node);
        } else {
          state.scenario.nodes.push(node);
        }

        if (type === "scene" && selectedNode && previousLinkedTargetId) {
          const newNodeIndex = state.scenario.nodes.findIndex((n) => n.id === id);
          const linkedNodeIndex = state.scenario.nodes.findIndex((n) => n.id === previousLinkedTargetId);
          if (newNodeIndex >= 0 && linkedNodeIndex >= 0 && linkedNodeIndex !== newNodeIndex + 1) {
            const [linkedNode] = state.scenario.nodes.splice(linkedNodeIndex, 1);
            const insertIndex = state.scenario.nodes.findIndex((n) => n.id === id) + 1;
            state.scenario.nodes.splice(insertIndex, 0, linkedNode);
          }
        }

        if (selectedNode && state.uiPositions[selectedNode.id]) {
          const selectedPos = state.uiPositions[selectedNode.id];
          const preferred = {
            x: selectedPos.x + 250,
            y: selectedPos.y
          };
          state.uiPositions[id] = findAvailableNodePosition(preferred, id);

          if (type === "scene" && previousLinkedTargetId && state.uiPositions[previousLinkedTargetId]) {
            const linkedPos = state.uiPositions[previousLinkedTargetId];
            if (linkedPos.x === state.uiPositions[id].x && linkedPos.y === state.uiPositions[id].y) {
              state.uiPositions[previousLinkedTargetId] = {
                x: linkedPos.x + 250,
                y: linkedPos.y
              };
            }
          }
        }

        renderNodes();
        if (type === "scene") {
          selectNode(id);
        } else {
          renderNodes();
        }
        persistDraft();
        markScenarioDirty();
      }

      async function createProject() {
        const res = await fetch("/api/projects", {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({
            name: el.projectName.value,
            slug: el.projectSlug.value
          })
        });
        const body = await res.json();
        if (res.ok) {
          state.projectId = body.project?.id || state.projectId;
          el.projectStatus.textContent = `project: ${body.project?.id ?? "created"} (${body.correlationId})`;
          persistDraft();
          markScenarioDirty();
          log("Project created.");
        } else {
          el.projectStatus.textContent = `${body.code}: ${body.message}`;
          log(`${body.code} ${body.message}`, true);
        }
      }

      async function saveScenario(options = {}) {
        const { silent = false } = options;
        const res = await fetch(`/api/projects/${state.projectId}/scenario`, {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({
            requestedVersion: state.scenarioVersion,
            currentVersion: state.scenarioVersion,
            content: state.scenario
          })
        });
        const body = await res.json();
        if (res.ok) {
          state.scenarioVersion = body.nextVersion;
          state.autosaveDirty = false;
          state.autosaveQueued = false;
          state.autosaveHadError = false;
          persistDraft();
          if (!silent) {
            log(`Scenario saved. version=${state.scenarioVersion}`);
          }
          return true;
        } else {
          if (!silent) {
            log(`${body.code} ${body.message}`, true);
          }
          return false;
        }
      }

      async function validateScenario() {
        const res = await fetch(`/api/projects/${state.projectId}/validate`, {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({ scenario: state.scenario })
        });
        const body = await res.json();
        const issues = body.issues || body.details?.errors || [];
        el.issues.innerHTML = "";
        el.issueCount.textContent = String(issues.length);
        issues.forEach((issue) => {
          const div = document.createElement("div");
          div.className = "issue";
          div.innerHTML = `<strong>${issue.code}</strong> ${issue.message}`;
          el.issues.appendChild(div);
        });
        if (res.ok) {
          log("Validation passed.");
        } else {
          log(`${body.code} (${issues.length} issues)`, true);
        }
      }

      async function buildSeo() {
        const res = await fetch(`/api/projects/${state.projectId}/build`, {
          method: "POST",
          headers: headers(),
          body: JSON.stringify({ jobType: "seo" })
        });
        const body = await res.json();
        if (res.ok) {
          log(`Build queued (${body.jobType})`);
        } else {
          log(`${body.code}: ${body.message}`, true);
        }
      }

      async function openPlayer() {
        const projectRef = state.projectId || el.projectSlug.value?.trim();
        if (!projectRef) {
          log("No project id/slug available for player test.", true);
          return;
        }
        const saved = await saveScenario({ silent: true });
        if (!saved) {
          log("Play Test aborted: scenario save failed.", true);
          return;
        }
        const target = `${playerBaseUrl}/play/${encodeURIComponent(projectRef)}`;
        window.open(target, "_blank", "noopener,noreferrer");
        log(`Opened player test: ${projectRef}`);
      }

      function toggleConnectMode() {
        log("Drag scene node onto scene node to connect next. Drag asset node onto scene node to apply asset.");
      }

      el.createProjectBtn.onclick = createProject;
      el.addScene.onclick = () => addNode("scene");
      el.addAsset.onclick = () => addNode("asset");
      el.autoLayout.onclick = autoLayoutNodes;
      el.saveScenario.onclick = saveScenario;
      el.validateScenario.onclick = validateScenario;
      el.connectNode.onclick = toggleConnectMode;
      el.buildSeo.onclick = buildSeo;
      el.openPlayer.onclick = openPlayer;
      el.deleteNode.onclick = deleteSelectedNode;
      el.assetUpload.onclick = () => el.assetUploadFile.click();
      el.applyAssetToLastScene.onclick = applySelectedAssetToLastScene;
      el.assetUploadFile.addEventListener("change", () => {
        const file = el.assetUploadFile.files?.[0];
        if (file) {
          uploadSelectedAssetNodeFile(file);
        }
        el.assetUploadFile.value = "";
      });
      el.projectName.addEventListener("change", persistDraft);
      el.projectSlug.addEventListener("change", persistDraft);
      el.assetKind.addEventListener("change", () => applyNodeChanges({ silent: true }));
      [el.nodeText, el.nodeSpeaker, el.nodeTextSpeed, el.nodeNext, el.nodeBackground, el.nodeCharacterLeft, el.nodeCharacterCenter, el.nodeCharacterRight, el.nodeMusic, el.assetKind, el.assetLabel, el.assetUrl].forEach((input) => {
        input.addEventListener("input", () => applyNodeChanges({ silent: true }));
      });

      restoreDraft();
      normalizeScenarioNodeTypes();
      renderNodes();
      selectNode(state.scenario.entryNodeId || "n_start");
    </script>
  </body>
</html>
