import { e as createComponent, r as renderTemplate, k as defineScriptVars, l as renderHead } from '../chunks/astro/server_BWx0qOMJ.mjs';
import 'piccolore';
import 'clsx';
/* empty css                                 */
export { renderers } from '../renderers.mjs';

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const defaultScenario = {
    meta: { schemaVersion: "1.0.0", title: "New VN" },
    entryNodeId: "n_start",
    nodes: [
      { id: "n_start", type: "scene", next: "n_end", data: { text: "첫 장면입니다." } },
      { id: "n_end", type: "scene", next: null, data: { text: "마지막 장면입니다." } }
    ]
  };
  const playerBaseUrl = "http://localhost:4322";
  return renderTemplate(_a || (_a = __template(['<html lang="ko" data-astro-cid-j7pv25f6> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>VN Studio</title>', '</head> <body data-astro-cid-j7pv25f6> <main class="layout" data-astro-cid-j7pv25f6> <section class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h1 data-astro-cid-j7pv25f6>PIXEL VN STUDIO</h1> <h3 data-astro-cid-j7pv25f6>Project + Scenario Authoring</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label data-astro-cid-j7pv25f6>Project Name <input id="projectName" value="My VN" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Project Slug <input id="projectSlug" value="my-vn" data-astro-cid-j7pv25f6></label> <button class="primary" id="createProjectBtn" data-astro-cid-j7pv25f6>Create Project</button> <div id="projectStatus" class="mono" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="group stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTOR CONTEXT</h2> <label data-astro-cid-j7pv25f6>Role\n<select id="role" data-astro-cid-j7pv25f6> <option value="owner" data-astro-cid-j7pv25f6>owner</option> <option value="editor" selected data-astro-cid-j7pv25f6>editor</option> <option value="viewer" data-astro-cid-j7pv25f6>viewer</option> </select> </label> <label data-astro-cid-j7pv25f6>Plan\n<select id="plan" data-astro-cid-j7pv25f6> <option value="free" selected data-astro-cid-j7pv25f6>free</option> <option value="pro" data-astro-cid-j7pv25f6>pro</option> </select> </label> <label data-astro-cid-j7pv25f6>User ID <input id="userId" value="00000000-0000-0000-0000-000000000010" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Org ID <input id="orgId" value="00000000-0000-0000-0000-000000000020" data-astro-cid-j7pv25f6></label> </div> </section> <section class="panel editor-panel" data-astro-cid-j7pv25f6> <div class="toolbar" data-astro-cid-j7pv25f6> <button id="addScene" data-astro-cid-j7pv25f6>+ Scene</button> <button id="addAsset" data-astro-cid-j7pv25f6>+ Asset</button> <button id="autoLayout" data-astro-cid-j7pv25f6>Auto Layout</button> <button id="saveScenario" class="primary" data-astro-cid-j7pv25f6>Save Scenario</button> <button id="validateScenario" data-astro-cid-j7pv25f6>Validate</button> <button id="connectNode" data-astro-cid-j7pv25f6>Connect (Drag)</button> <button id="buildSeo" class="warn" data-astro-cid-j7pv25f6>Build SEO</button> <button id="openPlayer" data-astro-cid-j7pv25f6>Play Test</button> </div> <div class="canvas" id="nodeCanvas" data-astro-cid-j7pv25f6></div> </section> <aside class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>NODE PROPERTIES</h2> <h3 id="selectedNodeLabel" data-astro-cid-j7pv25f6>No node selected</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label id="nodeTextField" data-astro-cid-j7pv25f6><span id="nodeTextLabel" data-astro-cid-j7pv25f6>Node Text</span> <textarea id="nodeText" rows="5" placeholder="scene text" data-astro-cid-j7pv25f6></textarea> </label> <label id="nodeSpeakerField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Character Name</span> <input id="nodeSpeaker" placeholder="Narrator" data-astro-cid-j7pv25f6> </label> <label id="nodeTextSpeedField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Text Speed (ms, 0 = instant)</span> <input id="nodeTextSpeed" type="number" min="0" max="96" step="1" placeholder="24" data-astro-cid-j7pv25f6> </label> <label id="nodeNextField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Next Node ID</span> <input id="nodeNext" placeholder="n_end" data-astro-cid-j7pv25f6> </label> <label id="assetKindField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Asset Kind</span> <select id="assetKind" data-astro-cid-j7pv25f6> <option value="background" data-astro-cid-j7pv25f6>background</option> <option value="character" data-astro-cid-j7pv25f6>character</option> <option value="music" data-astro-cid-j7pv25f6>music</option> </select> </label> <label id="assetLabelField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Asset Label</span> <input id="assetLabel" placeholder="asset label" data-astro-cid-j7pv25f6> </label> <label id="assetUrlField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Asset URL</span> <input id="assetUrl" placeholder="/api/assets/.../file.png" data-astro-cid-j7pv25f6> </label> <button id="assetUpload" type="button" data-astro-cid-j7pv25f6>에셋 업로드</button> <button id="applyAssetToLastScene" type="button" data-astro-cid-j7pv25f6>선택 씬 일괄 적용</button> <input id="assetUploadFile" type="file" accept="image/*,audio/*" class="hidden" data-astro-cid-j7pv25f6> <label data-astro-cid-j7pv25f6>Background URL\n<input id="nodeBackground" placeholder="/assets/bg/school.jpg" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Left URL\n<input id="nodeCharacterLeft" placeholder="/assets/char/left.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Center URL\n<input id="nodeCharacterCenter" placeholder="/assets/char/center.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Right URL\n<input id="nodeCharacterRight" placeholder="/assets/char/right.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>BGM URL\n<input id="nodeMusic" placeholder="/assets/bgm/theme.mp3" data-astro-cid-j7pv25f6> </label> <button id="deleteNode" class="warn" data-astro-cid-j7pv25f6>Delete Node</button> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>VALIDATION ISSUES <span id="issueCount" class="badge" data-astro-cid-j7pv25f6>0</span></h2> <div id="issues" class="issues" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTIVITY</h2> <div id="activity" class="mono" data-astro-cid-j7pv25f6></div> </div> </aside> </main> <script type="module">', '\n      const state = {\n        projectId: "p1",\n        scenarioVersion: 1,\n        selectedNodeId: null,\n        connectFromId: null,\n        draggingNodeId: null,\n        connectDrag: null,\n        connectHoverNodeId: null,\n        scenario: structuredClone(defaultScenario),\n        uiPositions: {},\n        lastSelectedSceneId: null,\n        multiSelectedSceneIds: [],\n        marquee: null,\n        assetDropNodeId: null,\n        autosaveTimer: null,\n        autosaveDirty: false,\n        autosaveInFlight: false,\n        autosaveQueued: false,\n        autosaveHadError: false\n      };\n\n      const el = {\n        projectName: document.getElementById("projectName"),\n        projectSlug: document.getElementById("projectSlug"),\n        createProjectBtn: document.getElementById("createProjectBtn"),\n        projectStatus: document.getElementById("projectStatus"),\n        role: document.getElementById("role"),\n        plan: document.getElementById("plan"),\n        userId: document.getElementById("userId"),\n        orgId: document.getElementById("orgId"),\n        nodeCanvas: document.getElementById("nodeCanvas"),\n        selectedNodeLabel: document.getElementById("selectedNodeLabel"),\n        nodeTextField: document.getElementById("nodeTextField"),\n        nodeTextLabel: document.getElementById("nodeTextLabel"),\n        nodeText: document.getElementById("nodeText"),\n        nodeSpeakerField: document.getElementById("nodeSpeakerField"),\n        nodeSpeaker: document.getElementById("nodeSpeaker"),\n        nodeTextSpeedField: document.getElementById("nodeTextSpeedField"),\n        nodeTextSpeed: document.getElementById("nodeTextSpeed"),\n        nodeNextField: document.getElementById("nodeNextField"),\n        nodeNext: document.getElementById("nodeNext"),\n        assetKindField: document.getElementById("assetKindField"),\n        assetKind: document.getElementById("assetKind"),\n        assetLabelField: document.getElementById("assetLabelField"),\n        assetLabel: document.getElementById("assetLabel"),\n        assetUrlField: document.getElementById("assetUrlField"),\n        assetUrl: document.getElementById("assetUrl"),\n        assetUpload: document.getElementById("assetUpload"),\n        applyAssetToLastScene: document.getElementById("applyAssetToLastScene"),\n        assetUploadFile: document.getElementById("assetUploadFile"),\n        nodeBackground: document.getElementById("nodeBackground"),\n        nodeCharacterLeft: document.getElementById("nodeCharacterLeft"),\n        nodeCharacterCenter: document.getElementById("nodeCharacterCenter"),\n        nodeCharacterRight: document.getElementById("nodeCharacterRight"),\n        nodeMusic: document.getElementById("nodeMusic"),\n        deleteNode: document.getElementById("deleteNode"),\n        addScene: document.getElementById("addScene"),\n        addAsset: document.getElementById("addAsset"),\n        autoLayout: document.getElementById("autoLayout"),\n        saveScenario: document.getElementById("saveScenario"),\n        validateScenario: document.getElementById("validateScenario"),\n        connectNode: document.getElementById("connectNode"),\n        buildSeo: document.getElementById("buildSeo"),\n        openPlayer: document.getElementById("openPlayer"),\n        issues: document.getElementById("issues"),\n        issueCount: document.getElementById("issueCount"),\n        activity: document.getElementById("activity")\n      };\n\n      function headers(options = {}) {\n        const { json = true } = options;\n        const base = {\n          "x-user-role": el.role.value,\n          "x-plan-tier": el.plan.value,\n          "x-user-id": el.userId.value,\n          "x-org-id": el.orgId.value\n        };\n        if (json) {\n          base["content-type"] = "application/json";\n        }\n        return base;\n      }\n\n      function draftKey() {\n        const ref = state.projectId || el.projectSlug.value || "default";\n        return `vn.studio.draft.${ref}`;\n      }\n\n      function persistDraft() {\n        const snapshot = {\n          projectId: state.projectId,\n          scenarioVersion: state.scenarioVersion,\n          scenario: state.scenario,\n          uiPositions: state.uiPositions,\n          projectName: el.projectName.value,\n          projectSlug: el.projectSlug.value\n        };\n        localStorage.setItem(draftKey(), JSON.stringify(snapshot));\n      }\n\n      function restoreDraft() {\n        const currentRef = state.projectId || el.projectSlug.value;\n        if (!currentRef) {\n          return;\n        }\n        const raw = localStorage.getItem(`vn.studio.draft.${currentRef}`);\n        if (!raw) {\n          return;\n        }\n        try {\n          const parsed = JSON.parse(raw);\n          if (parsed.projectId) state.projectId = parsed.projectId;\n          if (Number.isInteger(parsed.scenarioVersion)) state.scenarioVersion = parsed.scenarioVersion;\n          if (parsed.projectName) el.projectName.value = parsed.projectName;\n          if (parsed.projectSlug) el.projectSlug.value = parsed.projectSlug;\n          if (parsed.scenario?.entryNodeId && Array.isArray(parsed.scenario?.nodes)) {\n            state.scenario = parsed.scenario;\n            normalizeScenarioNodeTypes();\n          }\n          if (parsed.uiPositions && typeof parsed.uiPositions === "object") {\n            state.uiPositions = parsed.uiPositions;\n          }\n          log("Draft restored from local storage.");\n        } catch (error) {\n          log(`Draft restore failed: ${error.message}`, true);\n        }\n      }\n\n      function log(message, error = false) {\n        const line = document.createElement("div");\n        line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;\n        line.className = error ? "error" : "ok";\n        el.activity.prepend(line);\n      }\n\n      function normalizeScenarioNodeTypes() {\n        for (const node of state.scenario.nodes || []) {\n          node.data = node.data || {};\n          if (node.type !== "scene" && node.type !== "asset") {\n            const fallbackText = node.data?.text ?? node.data?.prompt ?? node.data?.title ?? "";\n            node.type = "scene";\n            node.data.text = fallbackText;\n            delete node.data.prompt;\n            delete node.data.options;\n            delete node.data.title;\n            delete node.data.endingId;\n          }\n          if (node.type === "scene") {\n            const legacyTargets = Array.isArray(node.data?.options)\n              ? node.data.options.map((o) => o?.to).filter(Boolean)\n              : [];\n            const normalizedTargets = Array.isArray(node.data?.targets) && node.data.targets.length > 0\n              ? node.data.targets.filter(Boolean)\n              : [node.next, ...legacyTargets].filter(Boolean);\n            setSceneTargets(node, normalizedTargets);\n            delete node.data.options;\n            delete node.data.prompt;\n            delete node.data.title;\n            delete node.data.endingId;\n            const normalizedCharacters = normalizeSceneCharacters(node);\n            if (normalizedCharacters.length > 0) {\n              setSceneCharacters(node, normalizedCharacters);\n              delete node.data.characterImage;\n            } else {\n              delete node.data.characters;\n            }\n          }\n          if (node.type === "asset") {\n            node.data.assetKind = ["background", "character", "music"].includes(node.data.assetKind) ? node.data.assetKind : "background";\n            node.data.label = node.data.label || "asset";\n            node.data.url = node.data.url || "";\n            delete node.next;\n          }\n        }\n      }\n\n      function normalizeCharacterSlot(slot, fallback = "right") {\n        return ["left", "center", "right"].includes(slot) ? slot : fallback;\n      }\n\n      function normalizeSceneCharacters(node) {\n        if (!node || node.type !== "scene") {\n          return [];\n        }\n        const raw = Array.isArray(node.data?.characters) ? node.data.characters : [];\n        const normalized = [];\n        for (const item of raw) {\n          if (!item || typeof item !== "object") {\n            continue;\n          }\n          const image = String(item.image || item.url || "").trim();\n          if (!image) {\n            continue;\n          }\n          normalized.push({ slot: normalizeCharacterSlot(item.slot), image });\n        }\n        if (normalized.length > 0) {\n          return normalized;\n        }\n        const legacy = String(node.data?.characterImage || "").trim();\n        if (!legacy) {\n          return [];\n        }\n        return [{ slot: "right", image: legacy }];\n      }\n\n      function getSceneCharacters(node) {\n        return normalizeSceneCharacters(node);\n      }\n\n      function setSceneCharacters(node, characters) {\n        if (!node || node.type !== "scene") {\n          return;\n        }\n        const uniqueBySlot = new Map();\n        for (const character of characters || []) {\n          if (!character?.image) {\n            continue;\n          }\n          uniqueBySlot.set(normalizeCharacterSlot(character.slot), {\n            slot: normalizeCharacterSlot(character.slot),\n            image: String(character.image).trim()\n          });\n        }\n        const ordered = ["left", "center", "right"]\n          .map((slot) => uniqueBySlot.get(slot))\n          .filter(Boolean);\n        if (ordered.length > 0) {\n          node.data.characters = ordered;\n        } else {\n          delete node.data.characters;\n        }\n      }\n\n      function findAvailableNodePosition(preferred, ignoreNodeId = null) {\n        const nodeWidth = 220;\n        const nodeHeight = 130;\n        const xStep = 250;\n        const yStep = 170;\n        const isOccupied = (candidateX, candidateY) => {\n          return state.scenario.nodes.some((node) => {\n            if (node.id === ignoreNodeId) return false;\n            const pos = state.uiPositions[node.id];\n            if (!pos) return false;\n            const overlapX = Math.abs(pos.x - candidateX) < nodeWidth;\n            const overlapY = Math.abs(pos.y - candidateY) < nodeHeight;\n            return overlapX && overlapY;\n          });\n        };\n\n        for (let i = 0; i < 200; i += 1) {\n          const col = i % 6;\n          const row = Math.floor(i / 6);\n          const x = preferred.x + col * xStep;\n          const y = preferred.y + row * yStep;\n          if (!isOccupied(x, y)) {\n            return { x, y };\n          }\n        }\n        return { x: preferred.x, y: preferred.y };\n      }\n\n      function markScenarioDirty() {\n        state.autosaveDirty = true;\n        scheduleAutosave();\n      }\n\n      function scheduleAutosave() {\n        if (state.autosaveTimer) {\n          clearTimeout(state.autosaveTimer);\n        }\n        state.autosaveTimer = setTimeout(() => {\n          state.autosaveTimer = null;\n          flushAutosave();\n        }, 1200);\n      }\n\n      async function flushAutosave() {\n        if (!state.autosaveDirty) {\n          return;\n        }\n        if (state.autosaveInFlight) {\n          state.autosaveQueued = true;\n          return;\n        }\n\n        state.autosaveInFlight = true;\n        state.autosaveDirty = false;\n        const saved = await saveScenario({ silent: true });\n        state.autosaveInFlight = false;\n\n        if (saved) {\n          if (state.autosaveHadError) {\n            log("Auto-save recovered.");\n          }\n          state.autosaveHadError = false;\n        } else {\n          state.autosaveDirty = true;\n          if (!state.autosaveHadError) {\n            log("Auto-save failed. Check project setup/permissions.", true);\n          }\n          state.autosaveHadError = true;\n        }\n\n        if (state.autosaveDirty || state.autosaveQueued) {\n          state.autosaveQueued = false;\n          scheduleAutosave();\n        }\n      }\n\n      function currentProjectRef() {\n        return state.projectId || (el.projectSlug.value || "").trim() || "default";\n      }\n\n      function inferAssetKindFromFile(file) {\n        const mime = String(file?.type || "").toLowerCase();\n        if (mime.startsWith("audio/")) {\n          return "music";\n        }\n        if (mime.startsWith("image/")) {\n          return "background";\n        }\n        return null;\n      }\n\n      async function uploadAssetFile(file, kind) {\n        if (!(file instanceof File)) {\n          return { ok: false, message: "No file selected." };\n        }\n        const ref = currentProjectRef();\n        const form = new FormData();\n        form.set("kind", kind);\n        form.set("file", file);\n        try {\n          const res = await fetch(`/api/projects/${encodeURIComponent(ref)}/assets`, {\n            method: "POST",\n            headers: headers({ json: false }),\n            body: form\n          });\n          const body = await res.json();\n          if (!res.ok || !body?.url) {\n            return { ok: false, message: `${body?.code ?? "UPLOAD_FAILED"}: ${body?.message ?? "Asset upload failed."}` };\n          }\n          return { ok: true, url: body.url };\n        } catch (error) {\n          return { ok: false, message: `Asset upload failed: ${error.message}` };\n        }\n      }\n\n      async function uploadSelectedAssetNodeFile(file) {\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node || node.type !== "asset") {\n          log("Select an asset node first.", true);\n          return;\n        }\n        const kind = inferAssetKindFromFile(file);\n        if (!kind) {\n          log("Only image/audio files are supported.", true);\n          return;\n        }\n        const result = await uploadAssetFile(file, kind);\n        if (!result.ok) {\n          log(result.message, true);\n          return;\n        }\n        el.assetKind.value = kind;\n        el.assetUrl.value = result.url;\n        if (!el.assetLabel.value.trim()) {\n          el.assetLabel.value = file.name || "asset";\n        }\n        applyNodeChanges({ silent: true });\n        log(`Asset uploaded: ${file.name}`);\n      }\n\n      function applyAssetNodeToScene(assetNodeId, sceneNodeId, options = {}) {\n        const { silent = false } = options;\n        const assetNode = state.scenario.nodes.find((n) => n.id === assetNodeId);\n        const sceneNode = state.scenario.nodes.find((n) => n.id === sceneNodeId);\n        if (!assetNode || !sceneNode) {\n          return;\n        }\n        if (assetNode.type !== "asset") {\n          return;\n        }\n        if (sceneNode.type !== "scene") {\n          log("Asset node can only be dropped on a scene node.", true);\n          return;\n        }\n        const kind = assetNode.data?.assetKind;\n        const url = (assetNode.data?.url || "").trim();\n        if (!url) {\n          log("Asset node has no URL.", true);\n          return;\n        }\n\n        sceneNode.data = sceneNode.data || {};\n        sceneNode.data.assetLinks = sceneNode.data.assetLinks || {};\n        if (kind === "background") {\n          sceneNode.data.background = url;\n          sceneNode.data.assetLinks.background = assetNode.id;\n        } else if (kind === "character") {\n          const existingCharacters = getSceneCharacters(sceneNode);\n          const occupiedSlots = new Set(existingCharacters.map((character) => character.slot));\n          const slot = ["left", "center", "right"].find((candidate) => !occupiedSlots.has(candidate)) || "right";\n          const nextCharacters = existingCharacters.filter((character) => character.slot !== slot);\n          nextCharacters.push({ slot, image: url });\n          setSceneCharacters(sceneNode, nextCharacters);\n          delete sceneNode.data.characterImage;\n          const linkedCharacters = Array.isArray(sceneNode.data.assetLinks.character)\n            ? sceneNode.data.assetLinks.character.filter(Boolean)\n            : (sceneNode.data.assetLinks.character ? [sceneNode.data.assetLinks.character] : []);\n          if (!linkedCharacters.includes(assetNode.id)) {\n            linkedCharacters.push(assetNode.id);\n          }\n          sceneNode.data.assetLinks.character = linkedCharacters;\n        } else if (kind === "music") {\n          sceneNode.data.music = url;\n          sceneNode.data.assetLinks.music = assetNode.id;\n        } else {\n          log("Unsupported asset kind.", true);\n          return;\n        }\n\n        if (state.selectedNodeId === sceneNode.id) {\n          selectNode(sceneNode.id);\n        } else {\n          renderNodes();\n        }\n        persistDraft();\n        markScenarioDirty();\n        if (!silent) {\n          log(`Applied ${kind} asset to ${sceneNode.id}`);\n        }\n      }\n\n      function applyAssetNodeToScenes(assetNodeId, sceneIds) {\n        const uniqueSceneIds = [...new Set((sceneIds || []).filter(Boolean))];\n        if (uniqueSceneIds.length === 0) {\n          log("적용할 씬이 없습니다.", true);\n          return;\n        }\n        let applied = 0;\n        for (const sceneId of uniqueSceneIds) {\n          const sceneNode = state.scenario.nodes.find((n) => n.id === sceneId);\n          if (!sceneNode || sceneNode.type !== "scene") {\n            continue;\n          }\n          applyAssetNodeToScene(assetNodeId, sceneId, { silent: true });\n          applied += 1;\n        }\n        if (applied === 0) {\n          log("선택된 씬에 적용할 수 없습니다.", true);\n          return;\n        }\n        log(`Asset applied to ${applied} scene node(s).`);\n      }\n\n      function ensureNodePosition(nodeId, fallbackIndex = 0) {\n        if (state.uiPositions[nodeId]) {\n          return state.uiPositions[nodeId];\n        }\n        const preferred = {\n          x: 24 + (fallbackIndex % 4) * 250,\n          y: 24 + Math.floor(fallbackIndex / 4) * 170\n        };\n        const position = findAvailableNodePosition(preferred, nodeId);\n        state.uiPositions[nodeId] = position;\n        return position;\n      }\n\n      function getEdgeList() {\n        const edges = [];\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene") {\n            const targets = getSceneTargets(node);\n            targets.forEach((to, index) => {\n              if (!to) return;\n              const label = targets.length >= 2 ? `opt${index + 1}` : "next";\n              edges.push({ from: node.id, to, label });\n            });\n          }\n        }\n        return edges;\n      }\n\n      function autoLayoutNodes() {\n        const nodes = state.scenario.nodes || [];\n        if (nodes.length === 0) {\n          return;\n        }\n\n        const adjacency = new Map();\n        for (const node of nodes) {\n          adjacency.set(node.id, []);\n        }\n        for (const edge of getEdgeList()) {\n          if (!adjacency.has(edge.from)) adjacency.set(edge.from, []);\n          adjacency.get(edge.from).push(edge.to);\n        }\n\n        const depthById = new Map();\n        const rootId = state.scenario.entryNodeId || nodes[0]?.id;\n        const queue = [];\n        if (rootId) {\n          depthById.set(rootId, 0);\n          queue.push(rootId);\n        }\n\n        while (queue.length > 0) {\n          const id = queue.shift();\n          const currentDepth = depthById.get(id) ?? 0;\n          for (const nextId of adjacency.get(id) || []) {\n            if (!depthById.has(nextId)) {\n              depthById.set(nextId, currentDepth + 1);\n              queue.push(nextId);\n            }\n          }\n        }\n\n        let fallbackDepth = 0;\n        for (const node of nodes) {\n          if (!depthById.has(node.id)) {\n            depthById.set(node.id, fallbackDepth + 1);\n            fallbackDepth += 1;\n          }\n        }\n\n        const lanes = new Map();\n        for (const node of nodes) {\n          const depth = depthById.get(node.id) ?? 0;\n          if (!lanes.has(depth)) lanes.set(depth, []);\n          lanes.get(depth).push(node.id);\n        }\n\n        const xGap = 280;\n        const yGap = 180;\n        for (const [depth, ids] of lanes.entries()) {\n          ids.forEach((id, rowIndex) => {\n            state.uiPositions[id] = {\n              x: 24 + depth * xGap,\n              y: 24 + rowIndex * yGap\n            };\n          });\n        }\n\n        renderNodes();\n        persistDraft();\n        log("Auto layout applied.");\n      }\n\n      function connectNodes(fromId, toId) {\n        const source = state.scenario.nodes.find((n) => n.id === fromId);\n        if (!source) {\n          return;\n        }\n        const target = state.scenario.nodes.find((n) => n.id === toId);\n        if (!target) {\n          return;\n        }\n        if (source.type !== "scene") {\n          log("Only scene nodes can connect to next nodes.", true);\n          return;\n        }\n        if (target.type !== "scene") {\n          log("Scene node can only connect to scene node.", true);\n          return;\n        }\n        const targets = getSceneTargets(source);\n        if (!targets.includes(toId)) {\n          targets.push(toId);\n        }\n        setSceneTargets(source, targets);\n        persistDraft();\n        markScenarioDirty();\n        if (state.selectedNodeId === source.id) {\n          selectNode(source.id);\n        } else {\n          renderNodes();\n        }\n        el.connectNode.textContent = "Connect (Drag)";\n        log(`Connected ${fromId} -> ${toId}`);\n      }\n\n      function canvasPointFromClient(clientX, clientY) {\n        const rect = el.nodeCanvas.getBoundingClientRect();\n        return {\n          x: clientX - rect.left + el.nodeCanvas.scrollLeft,\n          y: clientY - rect.top + el.nodeCanvas.scrollTop\n        };\n      }\n\n      function findNodeIdFromClient(clientX, clientY) {\n        const element = document.elementFromPoint(clientX, clientY);\n        const nodeEl = element?.closest?.(".node[data-node-id]");\n        if (!nodeEl) {\n          return null;\n        }\n        return nodeEl.getAttribute("data-node-id");\n      }\n\n      function getSelectedSceneIdsForAssetEdges() {\n        if (state.multiSelectedSceneIds.length > 0) {\n          return state.multiSelectedSceneIds.filter((id) => state.scenario.nodes.some((n) => n.id === id && n.type === "scene"));\n        }\n        if (state.selectedNodeId) {\n          const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n          if (node?.type === "scene") {\n            return [node.id];\n          }\n        }\n        return [];\n      }\n\n      function setMultiSceneSelection(ids) {\n        const sceneIds = new Set(\n          (ids || []).filter((id) => state.scenario.nodes.some((n) => n.id === id && n.type === "scene"))\n        );\n        state.multiSelectedSceneIds = [...sceneIds];\n      }\n\n      function toggleSceneSelection(id) {\n        if (!state.scenario.nodes.some((n) => n.id === id && n.type === "scene")) {\n          return;\n        }\n        const selected = new Set(state.multiSelectedSceneIds);\n        if (selected.has(id)) {\n          selected.delete(id);\n        } else {\n          selected.add(id);\n        }\n        state.multiSelectedSceneIds = [...selected];\n      }\n\n      function renderNodes() {\n        el.nodeCanvas.innerHTML = "";\n        const content = document.createElement("div");\n        content.className = "canvas-content";\n        el.nodeCanvas.appendChild(content);\n\n        const edgeLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg");\n        edgeLayer.setAttribute("class", "edge-layer");\n        content.appendChild(edgeLayer);\n\n        state.scenario.nodes.forEach((node, index) => ensureNodePosition(node.id, index));\n        const maxX = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.x ?? 0) + 260), 1200);\n        const maxY = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.y ?? 0) + 180), 900);\n        content.style.width = `${maxX}px`;\n        content.style.height = `${maxY}px`;\n\n        for (const edge of getEdgeList()) {\n          const fromPos = state.uiPositions[edge.from];\n          const toPos = state.uiPositions[edge.to];\n          if (!fromPos || !toPos) {\n            continue;\n          }\n          const x1 = fromPos.x + 220;\n          const y1 = fromPos.y + 46;\n          const x2 = toPos.x;\n          const y2 = toPos.y + 46;\n\n          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");\n          line.setAttribute("x1", String(x1));\n          line.setAttribute("y1", String(y1));\n          line.setAttribute("x2", String(x2));\n          line.setAttribute("y2", String(y2));\n          line.setAttribute("class", "edge-line");\n          edgeLayer.appendChild(line);\n\n          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");\n          label.setAttribute("x", String((x1 + x2) / 2));\n          label.setAttribute("y", String((y1 + y2) / 2 - 4));\n          label.setAttribute("class", "edge-label");\n          label.textContent = edge.label;\n          edgeLayer.appendChild(label);\n        }\n\n        const selectedScenesForAssetEdges = getSelectedSceneIdsForAssetEdges();\n        for (const sceneId of selectedScenesForAssetEdges) {\n          const sceneNode = state.scenario.nodes.find((n) => n.id === sceneId && n.type === "scene");\n          if (!sceneNode) continue;\n          const links = sceneNode.data?.assetLinks || {};\n          for (const [kind, assetNodeId] of Object.entries(links)) {\n            const linkedIds = Array.isArray(assetNodeId) ? assetNodeId : [assetNodeId];\n            for (const linkedId of linkedIds.filter(Boolean)) {\n              const assetNode = state.scenario.nodes.find((n) => n.id === linkedId && n.type === "asset");\n              if (!assetNode) continue;\n              const fromPos = state.uiPositions[sceneId];\n              const toPos = state.uiPositions[linkedId];\n              if (!fromPos || !toPos) continue;\n\n              const x1 = fromPos.x + 220;\n              const y1 = fromPos.y + 30;\n              const x2 = toPos.x;\n              const y2 = toPos.y + 30;\n\n              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");\n              line.setAttribute("x1", String(x1));\n              line.setAttribute("y1", String(y1));\n              line.setAttribute("x2", String(x2));\n              line.setAttribute("y2", String(y2));\n              line.setAttribute("class", "edge-line-asset");\n              edgeLayer.appendChild(line);\n\n              const label = document.createElementNS("http://www.w3.org/2000/svg", "text");\n              label.setAttribute("x", String((x1 + x2) / 2));\n              label.setAttribute("y", String((y1 + y2) / 2 - 6));\n              label.setAttribute("class", "edge-label-asset");\n              label.textContent = `asset:${kind}`;\n              edgeLayer.appendChild(label);\n            }\n          }\n        }\n\n        if (state.connectDrag) {\n          const fromPos = state.uiPositions[state.connectDrag.fromId];\n          if (fromPos) {\n            const x1 = fromPos.x + 220;\n            const y1 = fromPos.y + 46;\n            const x2 = state.connectDrag.x;\n            const y2 = state.connectDrag.y;\n            const preview = document.createElementNS("http://www.w3.org/2000/svg", "line");\n            preview.setAttribute("x1", String(x1));\n            preview.setAttribute("y1", String(y1));\n            preview.setAttribute("x2", String(x2));\n            preview.setAttribute("y2", String(y2));\n            preview.setAttribute("class", "edge-line");\n            preview.setAttribute("stroke-dasharray", "5 4");\n            edgeLayer.appendChild(preview);\n          }\n        }\n\n        if (state.marquee) {\n          const x = Math.min(state.marquee.x1, state.marquee.x2);\n          const y = Math.min(state.marquee.y1, state.marquee.y2);\n          const w = Math.abs(state.marquee.x2 - state.marquee.x1);\n          const h = Math.abs(state.marquee.y2 - state.marquee.y1);\n          const box = document.createElement("div");\n          box.className = "marquee-select";\n          box.style.left = `${x}px`;\n          box.style.top = `${y}px`;\n          box.style.width = `${w}px`;\n          box.style.height = `${h}px`;\n          content.appendChild(box);\n        }\n\n        for (const node of state.scenario.nodes) {\n          const div = document.createElement("div");\n          const isMultiSelectedScene = node.type === "scene" && state.multiSelectedSceneIds.includes(node.id);\n          const isSelected = state.selectedNodeId === node.id || state.connectFromId === node.id || isMultiSelectedScene;\n          const isDragging = state.draggingNodeId === node.id;\n          const isConnectTarget = state.connectHoverNodeId === node.id;\n          const isAssetDropTarget = state.assetDropNodeId === node.id;\n          const nodeTypeClass = node.type === "asset" ? "asset-node" : "scene-node";\n          div.className = `node ${nodeTypeClass} ${isSelected ? "selected" : ""} ${isDragging ? "dragging" : ""} ${isConnectTarget ? "connect-target" : ""} ${isAssetDropTarget ? "asset-drop-target" : ""}`;\n          div.setAttribute("data-node-id", node.id);\n          const pos = state.uiPositions[node.id];\n          div.style.left = `${pos.x}px`;\n          div.style.top = `${pos.y}px`;\n          const sceneTargets = node.type === "scene" ? getSceneTargets(node) : [];\n          const sceneState = node.type === "scene"\n            ? (sceneTargets.length === 0 ? "ending" : (sceneTargets.length >= 2 ? "option" : "normal"))\n            : "-";\n          const nodePreview = node.type === "asset"\n            ? (node.data?.label || node.data?.url || "(asset)")\n            : (node.data?.text || "(no text)");\n          const nodeNextDisplay = node.type === "scene" ? (sceneTargets[0] || "-") : "-";\n          const nodeAssetDisplay = node.type === "asset"\n            ? `${node.data?.assetKind || "-"}:${node.data?.url ? "y" : "-"}`\n            : "-";\n          div.innerHTML = `\n            <div class="node-meta"><span>${node.id}</span><span>${node.type}</span></div>\n            <div class="node-text">${nodePreview}</div>\n            <div class="node-row">\n              <span class="mono">next: ${nodeNextDisplay} / scene:${sceneState} / asset:${nodeAssetDisplay}</span>\n              <span class="connect-handle" data-role="connect-handle" title="Drag to connect/apply"></span>\n            </div>\n            <div class="mono">bg:${node.data?.background ? "y" : "-"} char:${getSceneCharacters(node).length > 0 || node.data?.characterImage ? "y" : "-"} bgm:${node.data?.music ? "y" : "-"} spd:${Number.isFinite(Number(node.data?.textSpeed)) ? Math.round(Number(node.data?.textSpeed)) : "-"}</div>\n          `;\n          div.onpointerdown = (event) => {\n            const isHandle = event.target?.closest?.("[data-role=\'connect-handle\']");\n            if (isHandle) {\n              event.preventDefault();\n              event.stopPropagation();\n              state.connectDrag = {\n                fromId: node.id,\n                ...canvasPointFromClient(event.clientX, event.clientY)\n              };\n              state.connectHoverNodeId = null;\n              state.connectFromId = node.id;\n              const onMove = (moveEvent) => {\n                state.connectDrag = {\n                  fromId: node.id,\n                  ...canvasPointFromClient(moveEvent.clientX, moveEvent.clientY)\n                };\n                const hovered = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);\n                state.connectHoverNodeId = hovered && hovered !== node.id ? hovered : null;\n                renderNodes();\n              };\n              const onUp = () => {\n                window.removeEventListener("pointermove", onMove);\n                window.removeEventListener("pointerup", onUp);\n                if (state.connectHoverNodeId && state.connectHoverNodeId !== node.id) {\n                  if (node.type === "scene") {\n                    connectNodes(node.id, state.connectHoverNodeId);\n                  } else if (node.type === "asset") {\n                    const selectedScenes = state.multiSelectedSceneIds.length > 0\n                      ? state.multiSelectedSceneIds\n                      : (state.lastSelectedSceneId ? [state.lastSelectedSceneId] : []);\n                    if (selectedScenes.length > 0) {\n                      applyAssetNodeToScenes(node.id, selectedScenes);\n                    } else {\n                      applyAssetNodeToScene(node.id, state.connectHoverNodeId);\n                    }\n                  }\n                }\n                state.connectDrag = null;\n                state.connectHoverNodeId = null;\n                state.connectFromId = null;\n                renderNodes();\n              };\n              window.addEventListener("pointermove", onMove);\n              window.addEventListener("pointerup", onUp);\n              return;\n            }\n\n            event.preventDefault();\n            state.draggingNodeId = node.id;\n            const start = canvasPointFromClient(event.clientX, event.clientY);\n            const origin = { ...state.uiPositions[node.id] };\n            const toggleMulti = Boolean(event.ctrlKey || event.metaKey);\n            let dragged = false;\n            let lastClientX = event.clientX;\n            let lastClientY = event.clientY;\n            const onMove = (moveEvent) => {\n              lastClientX = moveEvent.clientX;\n              lastClientY = moveEvent.clientY;\n              const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);\n              const dx = current.x - start.x;\n              const dy = current.y - start.y;\n              if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {\n                dragged = true;\n              }\n              state.uiPositions[node.id] = {\n                x: Math.max(8, origin.x + dx),\n                y: Math.max(8, origin.y + dy)\n              };\n              const hoveredNodeId = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);\n              state.assetDropNodeId = hoveredNodeId && hoveredNodeId !== node.id ? hoveredNodeId : null;\n              renderNodes();\n            };\n            const onUp = () => {\n              window.removeEventListener("pointermove", onMove);\n              window.removeEventListener("pointerup", onUp);\n              state.draggingNodeId = null;\n              state.assetDropNodeId = null;\n              if (dragged) {\n                persistDraft();\n              } else {\n                if (node.type !== "scene") {\n                  selectNode(node.id, { preserveMulti: true });\n                } else if (toggleMulti) {\n                  toggleSceneSelection(node.id);\n                  selectNode(node.id, { preserveMulti: true });\n                } else {\n                  selectNode(node.id);\n                }\n              }\n              renderNodes();\n            };\n            window.addEventListener("pointermove", onMove);\n            window.addEventListener("pointerup", onUp);\n          };\n          content.appendChild(div);\n        }\n\n        const startMarqueeSelection = (event) => {\n          if (event.target?.closest?.(".node")) {\n            return;\n          }\n          if (event.button !== 0) {\n            return;\n          }\n          event.preventDefault();\n          const start = canvasPointFromClient(event.clientX, event.clientY);\n          const additive = Boolean(event.ctrlKey || event.metaKey);\n          const baseSelection = additive ? new Set(state.multiSelectedSceneIds) : new Set();\n          state.marquee = { x1: start.x, y1: start.y, x2: start.x, y2: start.y };\n          renderNodes();\n\n          const onMove = (moveEvent) => {\n            const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);\n            state.marquee = { x1: start.x, y1: start.y, x2: current.x, y2: current.y };\n            renderNodes();\n          };\n\n          const onUp = () => {\n            window.removeEventListener("pointermove", onMove);\n            window.removeEventListener("pointerup", onUp);\n            const marquee = state.marquee;\n            state.marquee = null;\n            if (!marquee) {\n              renderNodes();\n              return;\n            }\n            const x1 = Math.min(marquee.x1, marquee.x2);\n            const y1 = Math.min(marquee.y1, marquee.y2);\n            const x2 = Math.max(marquee.x1, marquee.x2);\n            const y2 = Math.max(marquee.y1, marquee.y2);\n            const isClick = Math.abs(marquee.x2 - marquee.x1) < 4 && Math.abs(marquee.y2 - marquee.y1) < 4;\n\n            if (isClick) {\n              if (!additive) {\n                setMultiSceneSelection([]);\n              }\n              renderNodes();\n              return;\n            }\n\n            const selectedByBox = state.scenario.nodes\n              .filter((n) => n.type === "scene")\n              .filter((n) => {\n                const p = state.uiPositions[n.id];\n                if (!p) return false;\n                const nx1 = p.x;\n                const ny1 = p.y;\n                const nx2 = p.x + 220;\n                const ny2 = p.y + 130;\n                return nx1 <= x2 && nx2 >= x1 && ny1 <= y2 && ny2 >= y1;\n              })\n              .map((n) => n.id);\n\n            const merged = new Set(baseSelection);\n            selectedByBox.forEach((id) => merged.add(id));\n            setMultiSceneSelection([...merged]);\n            if (state.multiSelectedSceneIds.length === 1) {\n              selectNode(state.multiSelectedSceneIds[0], { preserveMulti: true });\n            } else {\n              renderNodes();\n            }\n          };\n\n          window.addEventListener("pointermove", onMove);\n          window.addEventListener("pointerup", onUp);\n        };\n        content.onpointerdown = startMarqueeSelection;\n        el.nodeCanvas.onpointerdown = startMarqueeSelection;\n      }\n\n      function setFieldVisible(element, visible) {\n        element.classList.toggle("hidden", !visible);\n      }\n\n      function updateNodeFormByType(node) {\n        const isScene = node?.type === "scene";\n        const isAsset = node?.type === "asset";\n        el.nodeTextLabel.textContent = "Node Text";\n        setFieldVisible(el.nodeTextField, isScene);\n        setFieldVisible(el.nodeSpeakerField, isScene);\n        setFieldVisible(el.nodeTextSpeedField, isScene);\n        setFieldVisible(el.nodeNextField, false);\n        setFieldVisible(el.assetKindField, isAsset);\n        setFieldVisible(el.assetLabelField, isAsset);\n        setFieldVisible(el.assetUrlField, isAsset);\n        setFieldVisible(el.assetUpload, isAsset);\n        setFieldVisible(el.applyAssetToLastScene, isAsset);\n        setFieldVisible(el.nodeBackground.parentElement, isScene);\n        setFieldVisible(el.nodeCharacterLeft.parentElement, isScene);\n        setFieldVisible(el.nodeCharacterCenter.parentElement, isScene);\n        setFieldVisible(el.nodeCharacterRight.parentElement, isScene);\n        setFieldVisible(el.nodeMusic.parentElement, isScene);\n      }\n\n      function selectNode(id, options = {}) {\n        const { preserveMulti = false } = options;\n        state.selectedNodeId = id;\n        const node = state.scenario.nodes.find((n) => n.id === id);\n        if (!node) return;\n        if (!preserveMulti) {\n          if (node.type === "scene") {\n            setMultiSceneSelection([node.id]);\n          } else {\n            setMultiSceneSelection([]);\n          }\n        }\n        if (node.type === "scene") {\n          state.lastSelectedSceneId = node.id;\n        }\n        updateNodeFormByType(node);\n        el.selectedNodeLabel.textContent = `${node.id} (${node.type})`;\n        if (node.type === "asset") {\n          el.nodeText.value = "";\n          el.nodeSpeaker.value = "";\n          el.nodeTextSpeed.value = "";\n          el.nodeNext.value = "";\n          el.assetKind.value = node.data?.assetKind || "background";\n          el.assetLabel.value = node.data?.label || "";\n          el.assetUrl.value = node.data?.url || "";\n        } else {\n          const sceneTargets = getSceneTargets(node);\n          el.nodeText.value = node.data?.text ?? "";\n          el.nodeSpeaker.value = node.data?.speaker ?? "";\n          el.nodeTextSpeed.value = Number.isFinite(Number(node.data?.textSpeed)) ? String(Math.round(Number(node.data?.textSpeed))) : "";\n          el.nodeNext.value = sceneTargets[0] ?? "";\n          el.assetKind.value = "background";\n          el.assetLabel.value = "";\n          el.assetUrl.value = "";\n        }\n        el.nodeBackground.value = node.data?.background ?? "";\n        const characters = getSceneCharacters(node);\n        el.nodeCharacterLeft.value = characters.find((character) => character.slot === "left")?.image || "";\n        el.nodeCharacterCenter.value = characters.find((character) => character.slot === "center")?.image || "";\n        el.nodeCharacterRight.value = characters.find((character) => character.slot === "right")?.image || "";\n        el.nodeMusic.value = node.data?.music ?? "";\n        renderNodes();\n      }\n\n      function applySelectedAssetToLastScene() {\n        const assetNode = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!assetNode || assetNode.type !== "asset") {\n          log("Select an asset node first.", true);\n          return;\n        }\n        const selectedScenes = state.multiSelectedSceneIds.length > 0\n          ? state.multiSelectedSceneIds\n          : (state.lastSelectedSceneId ? [state.lastSelectedSceneId] : []);\n        if (selectedScenes.length === 0) {\n          log("적용할 씬을 먼저 선택하세요.", true);\n          return;\n        }\n        applyAssetNodeToScenes(assetNode.id, selectedScenes);\n      }\n\n      function getSceneTargets(node) {\n        if (!node || node.type !== "scene") {\n          return [];\n        }\n        const stored = Array.isArray(node.data?.targets) ? node.data.targets.filter(Boolean) : [];\n        if (stored.length > 0) {\n          return [...new Set(stored)];\n        }\n        return node.next ? [node.next] : [];\n      }\n\n      function setSceneTargets(node, targets) {\n        if (!node || node.type !== "scene") {\n          return;\n        }\n        const unique = [...new Set((targets || []).filter(Boolean))];\n        node.data = node.data || {};\n        node.data.targets = unique;\n        node.next = unique[0] || null;\n      }\n\n      function applyNodeChanges(options = {}) {\n        const { silent = true } = options;\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node) return;\n        node.data = node.data || {};\n        const speaker = (el.nodeSpeaker.value || "").trim();\n        const textSpeedInput = (el.nodeTextSpeed.value || "").trim();\n        const background = (el.nodeBackground.value || "").trim();\n        const characterLeft = (el.nodeCharacterLeft.value || "").trim();\n        const characterCenter = (el.nodeCharacterCenter.value || "").trim();\n        const characterRight = (el.nodeCharacterRight.value || "").trim();\n        const music = (el.nodeMusic.value || "").trim();\n        const assetKind = (el.assetKind.value || "background").trim();\n        const assetLabel = (el.assetLabel.value || "").trim();\n        const assetUrl = (el.assetUrl.value || "").trim();\n        if (node.type === "scene") {\n          node.data.text = el.nodeText.value;\n          const sceneTargets = getSceneTargets(node);\n          setSceneTargets(node, sceneTargets);\n          if (speaker) {\n            node.data.speaker = speaker;\n          } else {\n            delete node.data.speaker;\n          }\n          if (textSpeedInput === "") {\n            delete node.data.textSpeed;\n          } else {\n            const rawSpeed = Number(textSpeedInput);\n            if (Number.isFinite(rawSpeed)) {\n              node.data.textSpeed = Math.max(0, Math.min(96, Math.round(rawSpeed)));\n            }\n          }\n          delete node.data.assetKind;\n          delete node.data.label;\n          delete node.data.url;\n        } else if (node.type === "asset") {\n          node.data.assetKind = ["background", "character", "music"].includes(assetKind) ? assetKind : "background";\n          node.data.label = assetLabel || "asset";\n          node.data.url = assetUrl;\n          delete node.next;\n          delete node.data.text;\n          delete node.data.speaker;\n          delete node.data.textSpeed;\n          delete node.data.background;\n          delete node.data.characters;\n          delete node.data.characterImage;\n          delete node.data.music;\n        } else {\n          delete node.data.textSpeed;\n        }\n        if (node.type === "scene") {\n          if (background) {\n            node.data.background = background;\n          } else {\n            delete node.data.background;\n          }\n          setSceneCharacters(node, [\n            { slot: "left", image: characterLeft },\n            { slot: "center", image: characterCenter },\n            { slot: "right", image: characterRight }\n          ]);\n          delete node.data.characterImage;\n          if (music) {\n            node.data.music = music;\n          } else {\n            delete node.data.music;\n          }\n        }\n        renderNodes();\n        persistDraft();\n        markScenarioDirty();\n        if (!silent) {\n          log(`Applied changes to ${node.id}`);\n        }\n      }\n\n      function deleteSelectedNode() {\n        if (!state.selectedNodeId) {\n          log("No selected node to delete.", true);\n          return;\n        }\n        if (state.scenario.nodes.length <= 1) {\n          log("Cannot delete the last node.", true);\n          return;\n        }\n\n        const removeId = state.selectedNodeId;\n        state.scenario.nodes = state.scenario.nodes.filter((n) => n.id !== removeId);\n        delete state.uiPositions[removeId];\n        if (state.connectFromId === removeId) {\n          state.connectFromId = null;\n        }\n\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene") {\n            const targets = getSceneTargets(node).filter((id) => id !== removeId);\n            setSceneTargets(node, targets);\n            if (node.data?.assetLinks && typeof node.data.assetLinks === "object") {\n              for (const [kind, linkedId] of Object.entries(node.data.assetLinks)) {\n                if (linkedId === removeId) {\n                  delete node.data.assetLinks[kind];\n                } else if (Array.isArray(linkedId)) {\n                  const filtered = linkedId.filter((id) => id !== removeId);\n                  if (filtered.length > 0) {\n                    node.data.assetLinks[kind] = filtered;\n                  } else {\n                    delete node.data.assetLinks[kind];\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (state.scenario.entryNodeId === removeId) {\n          state.scenario.entryNodeId = state.scenario.nodes[0]?.id ?? null;\n        }\n        state.selectedNodeId = state.scenario.entryNodeId ?? state.scenario.nodes[0]?.id ?? null;\n        renderNodes();\n        if (state.selectedNodeId) {\n          selectNode(state.selectedNodeId);\n        }\n        persistDraft();\n        markScenarioDirty();\n        log(`Deleted node ${removeId}`);\n      }\n\n      function addNode(type, payload = null) {\n        const id = `n_${type}_${Math.random().toString(36).slice(2, 6)}`;\n        const node = { id, type, data: {} };\n        let previousLinkedTargetId = null;\n        if (type === "scene") {\n          node.data.text = "새 장면";\n          node.data.textSpeed = 24;\n          setSceneTargets(node, []);\n        }\n        if (type === "asset") {\n          node.data.assetKind = payload?.assetKind || "background";\n          node.data.label = payload?.label || "asset";\n          node.data.url = payload?.url || "";\n        }\n        const selectedIndex = state.scenario.nodes.findIndex((n) => n.id === state.selectedNodeId);\n        const selectedNode = selectedIndex >= 0 ? state.scenario.nodes[selectedIndex] : null;\n\n        if (type === "scene" && selectedNode) {\n          state.scenario.nodes.splice(selectedIndex + 1, 0, node);\n          if (selectedNode.type === "scene") {\n            const selectedTargets = getSceneTargets(selectedNode);\n            previousLinkedTargetId = selectedTargets[0] ?? null;\n            const restTargets = selectedTargets.slice(1);\n            setSceneTargets(selectedNode, [id, ...restTargets]);\n            setSceneTargets(node, previousLinkedTargetId ? [previousLinkedTargetId] : []);\n          }\n        } else if (selectedNode) {\n          state.scenario.nodes.splice(selectedIndex + 1, 0, node);\n        } else {\n          state.scenario.nodes.push(node);\n        }\n\n        if (type === "scene" && selectedNode && previousLinkedTargetId) {\n          const newNodeIndex = state.scenario.nodes.findIndex((n) => n.id === id);\n          const linkedNodeIndex = state.scenario.nodes.findIndex((n) => n.id === previousLinkedTargetId);\n          if (newNodeIndex >= 0 && linkedNodeIndex >= 0 && linkedNodeIndex !== newNodeIndex + 1) {\n            const [linkedNode] = state.scenario.nodes.splice(linkedNodeIndex, 1);\n            const insertIndex = state.scenario.nodes.findIndex((n) => n.id === id) + 1;\n            state.scenario.nodes.splice(insertIndex, 0, linkedNode);\n          }\n        }\n\n        if (selectedNode && state.uiPositions[selectedNode.id]) {\n          const selectedPos = state.uiPositions[selectedNode.id];\n          const preferred = {\n            x: selectedPos.x + 250,\n            y: selectedPos.y\n          };\n          state.uiPositions[id] = findAvailableNodePosition(preferred, id);\n\n          if (type === "scene" && previousLinkedTargetId && state.uiPositions[previousLinkedTargetId]) {\n            const linkedPos = state.uiPositions[previousLinkedTargetId];\n            if (linkedPos.x === state.uiPositions[id].x && linkedPos.y === state.uiPositions[id].y) {\n              state.uiPositions[previousLinkedTargetId] = {\n                x: linkedPos.x + 250,\n                y: linkedPos.y\n              };\n            }\n          }\n        }\n\n        renderNodes();\n        if (type === "scene") {\n          selectNode(id);\n        } else {\n          renderNodes();\n        }\n        persistDraft();\n        markScenarioDirty();\n      }\n\n      async function createProject() {\n        const res = await fetch("/api/projects", {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            name: el.projectName.value,\n            slug: el.projectSlug.value\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.projectId = body.project?.id || state.projectId;\n          el.projectStatus.textContent = `project: ${body.project?.id ?? "created"} (${body.correlationId})`;\n          persistDraft();\n          markScenarioDirty();\n          log("Project created.");\n        } else {\n          el.projectStatus.textContent = `${body.code}: ${body.message}`;\n          log(`${body.code} ${body.message}`, true);\n        }\n      }\n\n      async function saveScenario(options = {}) {\n        const { silent = false } = options;\n        const res = await fetch(`/api/projects/${state.projectId}/scenario`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            requestedVersion: state.scenarioVersion,\n            currentVersion: state.scenarioVersion,\n            content: state.scenario\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.scenarioVersion = body.nextVersion;\n          state.autosaveDirty = false;\n          state.autosaveQueued = false;\n          state.autosaveHadError = false;\n          persistDraft();\n          if (!silent) {\n            log(`Scenario saved. version=${state.scenarioVersion}`);\n          }\n          return true;\n        } else {\n          if (!silent) {\n            log(`${body.code} ${body.message}`, true);\n          }\n          return false;\n        }\n      }\n\n      async function validateScenario() {\n        const res = await fetch(`/api/projects/${state.projectId}/validate`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ scenario: state.scenario })\n        });\n        const body = await res.json();\n        const issues = body.issues || body.details?.errors || [];\n        el.issues.innerHTML = "";\n        el.issueCount.textContent = String(issues.length);\n        issues.forEach((issue) => {\n          const div = document.createElement("div");\n          div.className = "issue";\n          div.innerHTML = `<strong>${issue.code}</strong> ${issue.message}`;\n          el.issues.appendChild(div);\n        });\n        if (res.ok) {\n          log("Validation passed.");\n        } else {\n          log(`${body.code} (${issues.length} issues)`, true);\n        }\n      }\n\n      async function buildSeo() {\n        const res = await fetch(`/api/projects/${state.projectId}/build`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ jobType: "seo" })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          log(`Build queued (${body.jobType})`);\n        } else {\n          log(`${body.code}: ${body.message}`, true);\n        }\n      }\n\n      async function openPlayer() {\n        const projectRef = state.projectId || el.projectSlug.value?.trim();\n        if (!projectRef) {\n          log("No project id/slug available for player test.", true);\n          return;\n        }\n        const saved = await saveScenario({ silent: true });\n        if (!saved) {\n          log("Play Test aborted: scenario save failed.", true);\n          return;\n        }\n        const target = `${playerBaseUrl}/play/${encodeURIComponent(projectRef)}`;\n        window.open(target, "_blank", "noopener,noreferrer");\n        log(`Opened player test: ${projectRef}`);\n      }\n\n      function toggleConnectMode() {\n        log("Drag scene node onto scene node to connect next. Drag asset node onto scene node to apply asset.");\n      }\n\n      el.createProjectBtn.onclick = createProject;\n      el.addScene.onclick = () => addNode("scene");\n      el.addAsset.onclick = () => addNode("asset");\n      el.autoLayout.onclick = autoLayoutNodes;\n      el.saveScenario.onclick = saveScenario;\n      el.validateScenario.onclick = validateScenario;\n      el.connectNode.onclick = toggleConnectMode;\n      el.buildSeo.onclick = buildSeo;\n      el.openPlayer.onclick = openPlayer;\n      el.deleteNode.onclick = deleteSelectedNode;\n      el.assetUpload.onclick = () => el.assetUploadFile.click();\n      el.applyAssetToLastScene.onclick = applySelectedAssetToLastScene;\n      el.assetUploadFile.addEventListener("change", () => {\n        const file = el.assetUploadFile.files?.[0];\n        if (file) {\n          uploadSelectedAssetNodeFile(file);\n        }\n        el.assetUploadFile.value = "";\n      });\n      el.projectName.addEventListener("change", persistDraft);\n      el.projectSlug.addEventListener("change", persistDraft);\n      el.assetKind.addEventListener("change", () => applyNodeChanges({ silent: true }));\n      [el.nodeText, el.nodeSpeaker, el.nodeTextSpeed, el.nodeNext, el.nodeBackground, el.nodeCharacterLeft, el.nodeCharacterCenter, el.nodeCharacterRight, el.nodeMusic, el.assetKind, el.assetLabel, el.assetUrl].forEach((input) => {\n        input.addEventListener("input", () => applyNodeChanges({ silent: true }));\n      });\n\n      restoreDraft();\n      normalizeScenarioNodeTypes();\n      renderNodes();\n      selectNode(state.scenario.entryNodeId || "n_start");\n    </script> </body> </html>'], ['<html lang="ko" data-astro-cid-j7pv25f6> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>VN Studio</title>', '</head> <body data-astro-cid-j7pv25f6> <main class="layout" data-astro-cid-j7pv25f6> <section class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h1 data-astro-cid-j7pv25f6>PIXEL VN STUDIO</h1> <h3 data-astro-cid-j7pv25f6>Project + Scenario Authoring</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label data-astro-cid-j7pv25f6>Project Name <input id="projectName" value="My VN" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Project Slug <input id="projectSlug" value="my-vn" data-astro-cid-j7pv25f6></label> <button class="primary" id="createProjectBtn" data-astro-cid-j7pv25f6>Create Project</button> <div id="projectStatus" class="mono" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="group stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTOR CONTEXT</h2> <label data-astro-cid-j7pv25f6>Role\n<select id="role" data-astro-cid-j7pv25f6> <option value="owner" data-astro-cid-j7pv25f6>owner</option> <option value="editor" selected data-astro-cid-j7pv25f6>editor</option> <option value="viewer" data-astro-cid-j7pv25f6>viewer</option> </select> </label> <label data-astro-cid-j7pv25f6>Plan\n<select id="plan" data-astro-cid-j7pv25f6> <option value="free" selected data-astro-cid-j7pv25f6>free</option> <option value="pro" data-astro-cid-j7pv25f6>pro</option> </select> </label> <label data-astro-cid-j7pv25f6>User ID <input id="userId" value="00000000-0000-0000-0000-000000000010" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Org ID <input id="orgId" value="00000000-0000-0000-0000-000000000020" data-astro-cid-j7pv25f6></label> </div> </section> <section class="panel editor-panel" data-astro-cid-j7pv25f6> <div class="toolbar" data-astro-cid-j7pv25f6> <button id="addScene" data-astro-cid-j7pv25f6>+ Scene</button> <button id="addAsset" data-astro-cid-j7pv25f6>+ Asset</button> <button id="autoLayout" data-astro-cid-j7pv25f6>Auto Layout</button> <button id="saveScenario" class="primary" data-astro-cid-j7pv25f6>Save Scenario</button> <button id="validateScenario" data-astro-cid-j7pv25f6>Validate</button> <button id="connectNode" data-astro-cid-j7pv25f6>Connect (Drag)</button> <button id="buildSeo" class="warn" data-astro-cid-j7pv25f6>Build SEO</button> <button id="openPlayer" data-astro-cid-j7pv25f6>Play Test</button> </div> <div class="canvas" id="nodeCanvas" data-astro-cid-j7pv25f6></div> </section> <aside class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>NODE PROPERTIES</h2> <h3 id="selectedNodeLabel" data-astro-cid-j7pv25f6>No node selected</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label id="nodeTextField" data-astro-cid-j7pv25f6><span id="nodeTextLabel" data-astro-cid-j7pv25f6>Node Text</span> <textarea id="nodeText" rows="5" placeholder="scene text" data-astro-cid-j7pv25f6></textarea> </label> <label id="nodeSpeakerField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Character Name</span> <input id="nodeSpeaker" placeholder="Narrator" data-astro-cid-j7pv25f6> </label> <label id="nodeTextSpeedField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Text Speed (ms, 0 = instant)</span> <input id="nodeTextSpeed" type="number" min="0" max="96" step="1" placeholder="24" data-astro-cid-j7pv25f6> </label> <label id="nodeNextField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Next Node ID</span> <input id="nodeNext" placeholder="n_end" data-astro-cid-j7pv25f6> </label> <label id="assetKindField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Asset Kind</span> <select id="assetKind" data-astro-cid-j7pv25f6> <option value="background" data-astro-cid-j7pv25f6>background</option> <option value="character" data-astro-cid-j7pv25f6>character</option> <option value="music" data-astro-cid-j7pv25f6>music</option> </select> </label> <label id="assetLabelField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Asset Label</span> <input id="assetLabel" placeholder="asset label" data-astro-cid-j7pv25f6> </label> <label id="assetUrlField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Asset URL</span> <input id="assetUrl" placeholder="/api/assets/.../file.png" data-astro-cid-j7pv25f6> </label> <button id="assetUpload" type="button" data-astro-cid-j7pv25f6>에셋 업로드</button> <button id="applyAssetToLastScene" type="button" data-astro-cid-j7pv25f6>선택 씬 일괄 적용</button> <input id="assetUploadFile" type="file" accept="image/*,audio/*" class="hidden" data-astro-cid-j7pv25f6> <label data-astro-cid-j7pv25f6>Background URL\n<input id="nodeBackground" placeholder="/assets/bg/school.jpg" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Left URL\n<input id="nodeCharacterLeft" placeholder="/assets/char/left.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Center URL\n<input id="nodeCharacterCenter" placeholder="/assets/char/center.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Right URL\n<input id="nodeCharacterRight" placeholder="/assets/char/right.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>BGM URL\n<input id="nodeMusic" placeholder="/assets/bgm/theme.mp3" data-astro-cid-j7pv25f6> </label> <button id="deleteNode" class="warn" data-astro-cid-j7pv25f6>Delete Node</button> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>VALIDATION ISSUES <span id="issueCount" class="badge" data-astro-cid-j7pv25f6>0</span></h2> <div id="issues" class="issues" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTIVITY</h2> <div id="activity" class="mono" data-astro-cid-j7pv25f6></div> </div> </aside> </main> <script type="module">', '\n      const state = {\n        projectId: "p1",\n        scenarioVersion: 1,\n        selectedNodeId: null,\n        connectFromId: null,\n        draggingNodeId: null,\n        connectDrag: null,\n        connectHoverNodeId: null,\n        scenario: structuredClone(defaultScenario),\n        uiPositions: {},\n        lastSelectedSceneId: null,\n        multiSelectedSceneIds: [],\n        marquee: null,\n        assetDropNodeId: null,\n        autosaveTimer: null,\n        autosaveDirty: false,\n        autosaveInFlight: false,\n        autosaveQueued: false,\n        autosaveHadError: false\n      };\n\n      const el = {\n        projectName: document.getElementById("projectName"),\n        projectSlug: document.getElementById("projectSlug"),\n        createProjectBtn: document.getElementById("createProjectBtn"),\n        projectStatus: document.getElementById("projectStatus"),\n        role: document.getElementById("role"),\n        plan: document.getElementById("plan"),\n        userId: document.getElementById("userId"),\n        orgId: document.getElementById("orgId"),\n        nodeCanvas: document.getElementById("nodeCanvas"),\n        selectedNodeLabel: document.getElementById("selectedNodeLabel"),\n        nodeTextField: document.getElementById("nodeTextField"),\n        nodeTextLabel: document.getElementById("nodeTextLabel"),\n        nodeText: document.getElementById("nodeText"),\n        nodeSpeakerField: document.getElementById("nodeSpeakerField"),\n        nodeSpeaker: document.getElementById("nodeSpeaker"),\n        nodeTextSpeedField: document.getElementById("nodeTextSpeedField"),\n        nodeTextSpeed: document.getElementById("nodeTextSpeed"),\n        nodeNextField: document.getElementById("nodeNextField"),\n        nodeNext: document.getElementById("nodeNext"),\n        assetKindField: document.getElementById("assetKindField"),\n        assetKind: document.getElementById("assetKind"),\n        assetLabelField: document.getElementById("assetLabelField"),\n        assetLabel: document.getElementById("assetLabel"),\n        assetUrlField: document.getElementById("assetUrlField"),\n        assetUrl: document.getElementById("assetUrl"),\n        assetUpload: document.getElementById("assetUpload"),\n        applyAssetToLastScene: document.getElementById("applyAssetToLastScene"),\n        assetUploadFile: document.getElementById("assetUploadFile"),\n        nodeBackground: document.getElementById("nodeBackground"),\n        nodeCharacterLeft: document.getElementById("nodeCharacterLeft"),\n        nodeCharacterCenter: document.getElementById("nodeCharacterCenter"),\n        nodeCharacterRight: document.getElementById("nodeCharacterRight"),\n        nodeMusic: document.getElementById("nodeMusic"),\n        deleteNode: document.getElementById("deleteNode"),\n        addScene: document.getElementById("addScene"),\n        addAsset: document.getElementById("addAsset"),\n        autoLayout: document.getElementById("autoLayout"),\n        saveScenario: document.getElementById("saveScenario"),\n        validateScenario: document.getElementById("validateScenario"),\n        connectNode: document.getElementById("connectNode"),\n        buildSeo: document.getElementById("buildSeo"),\n        openPlayer: document.getElementById("openPlayer"),\n        issues: document.getElementById("issues"),\n        issueCount: document.getElementById("issueCount"),\n        activity: document.getElementById("activity")\n      };\n\n      function headers(options = {}) {\n        const { json = true } = options;\n        const base = {\n          "x-user-role": el.role.value,\n          "x-plan-tier": el.plan.value,\n          "x-user-id": el.userId.value,\n          "x-org-id": el.orgId.value\n        };\n        if (json) {\n          base["content-type"] = "application/json";\n        }\n        return base;\n      }\n\n      function draftKey() {\n        const ref = state.projectId || el.projectSlug.value || "default";\n        return \\`vn.studio.draft.\\${ref}\\`;\n      }\n\n      function persistDraft() {\n        const snapshot = {\n          projectId: state.projectId,\n          scenarioVersion: state.scenarioVersion,\n          scenario: state.scenario,\n          uiPositions: state.uiPositions,\n          projectName: el.projectName.value,\n          projectSlug: el.projectSlug.value\n        };\n        localStorage.setItem(draftKey(), JSON.stringify(snapshot));\n      }\n\n      function restoreDraft() {\n        const currentRef = state.projectId || el.projectSlug.value;\n        if (!currentRef) {\n          return;\n        }\n        const raw = localStorage.getItem(\\`vn.studio.draft.\\${currentRef}\\`);\n        if (!raw) {\n          return;\n        }\n        try {\n          const parsed = JSON.parse(raw);\n          if (parsed.projectId) state.projectId = parsed.projectId;\n          if (Number.isInteger(parsed.scenarioVersion)) state.scenarioVersion = parsed.scenarioVersion;\n          if (parsed.projectName) el.projectName.value = parsed.projectName;\n          if (parsed.projectSlug) el.projectSlug.value = parsed.projectSlug;\n          if (parsed.scenario?.entryNodeId && Array.isArray(parsed.scenario?.nodes)) {\n            state.scenario = parsed.scenario;\n            normalizeScenarioNodeTypes();\n          }\n          if (parsed.uiPositions && typeof parsed.uiPositions === "object") {\n            state.uiPositions = parsed.uiPositions;\n          }\n          log("Draft restored from local storage.");\n        } catch (error) {\n          log(\\`Draft restore failed: \\${error.message}\\`, true);\n        }\n      }\n\n      function log(message, error = false) {\n        const line = document.createElement("div");\n        line.textContent = \\`[\\${new Date().toLocaleTimeString()}] \\${message}\\`;\n        line.className = error ? "error" : "ok";\n        el.activity.prepend(line);\n      }\n\n      function normalizeScenarioNodeTypes() {\n        for (const node of state.scenario.nodes || []) {\n          node.data = node.data || {};\n          if (node.type !== "scene" && node.type !== "asset") {\n            const fallbackText = node.data?.text ?? node.data?.prompt ?? node.data?.title ?? "";\n            node.type = "scene";\n            node.data.text = fallbackText;\n            delete node.data.prompt;\n            delete node.data.options;\n            delete node.data.title;\n            delete node.data.endingId;\n          }\n          if (node.type === "scene") {\n            const legacyTargets = Array.isArray(node.data?.options)\n              ? node.data.options.map((o) => o?.to).filter(Boolean)\n              : [];\n            const normalizedTargets = Array.isArray(node.data?.targets) && node.data.targets.length > 0\n              ? node.data.targets.filter(Boolean)\n              : [node.next, ...legacyTargets].filter(Boolean);\n            setSceneTargets(node, normalizedTargets);\n            delete node.data.options;\n            delete node.data.prompt;\n            delete node.data.title;\n            delete node.data.endingId;\n            const normalizedCharacters = normalizeSceneCharacters(node);\n            if (normalizedCharacters.length > 0) {\n              setSceneCharacters(node, normalizedCharacters);\n              delete node.data.characterImage;\n            } else {\n              delete node.data.characters;\n            }\n          }\n          if (node.type === "asset") {\n            node.data.assetKind = ["background", "character", "music"].includes(node.data.assetKind) ? node.data.assetKind : "background";\n            node.data.label = node.data.label || "asset";\n            node.data.url = node.data.url || "";\n            delete node.next;\n          }\n        }\n      }\n\n      function normalizeCharacterSlot(slot, fallback = "right") {\n        return ["left", "center", "right"].includes(slot) ? slot : fallback;\n      }\n\n      function normalizeSceneCharacters(node) {\n        if (!node || node.type !== "scene") {\n          return [];\n        }\n        const raw = Array.isArray(node.data?.characters) ? node.data.characters : [];\n        const normalized = [];\n        for (const item of raw) {\n          if (!item || typeof item !== "object") {\n            continue;\n          }\n          const image = String(item.image || item.url || "").trim();\n          if (!image) {\n            continue;\n          }\n          normalized.push({ slot: normalizeCharacterSlot(item.slot), image });\n        }\n        if (normalized.length > 0) {\n          return normalized;\n        }\n        const legacy = String(node.data?.characterImage || "").trim();\n        if (!legacy) {\n          return [];\n        }\n        return [{ slot: "right", image: legacy }];\n      }\n\n      function getSceneCharacters(node) {\n        return normalizeSceneCharacters(node);\n      }\n\n      function setSceneCharacters(node, characters) {\n        if (!node || node.type !== "scene") {\n          return;\n        }\n        const uniqueBySlot = new Map();\n        for (const character of characters || []) {\n          if (!character?.image) {\n            continue;\n          }\n          uniqueBySlot.set(normalizeCharacterSlot(character.slot), {\n            slot: normalizeCharacterSlot(character.slot),\n            image: String(character.image).trim()\n          });\n        }\n        const ordered = ["left", "center", "right"]\n          .map((slot) => uniqueBySlot.get(slot))\n          .filter(Boolean);\n        if (ordered.length > 0) {\n          node.data.characters = ordered;\n        } else {\n          delete node.data.characters;\n        }\n      }\n\n      function findAvailableNodePosition(preferred, ignoreNodeId = null) {\n        const nodeWidth = 220;\n        const nodeHeight = 130;\n        const xStep = 250;\n        const yStep = 170;\n        const isOccupied = (candidateX, candidateY) => {\n          return state.scenario.nodes.some((node) => {\n            if (node.id === ignoreNodeId) return false;\n            const pos = state.uiPositions[node.id];\n            if (!pos) return false;\n            const overlapX = Math.abs(pos.x - candidateX) < nodeWidth;\n            const overlapY = Math.abs(pos.y - candidateY) < nodeHeight;\n            return overlapX && overlapY;\n          });\n        };\n\n        for (let i = 0; i < 200; i += 1) {\n          const col = i % 6;\n          const row = Math.floor(i / 6);\n          const x = preferred.x + col * xStep;\n          const y = preferred.y + row * yStep;\n          if (!isOccupied(x, y)) {\n            return { x, y };\n          }\n        }\n        return { x: preferred.x, y: preferred.y };\n      }\n\n      function markScenarioDirty() {\n        state.autosaveDirty = true;\n        scheduleAutosave();\n      }\n\n      function scheduleAutosave() {\n        if (state.autosaveTimer) {\n          clearTimeout(state.autosaveTimer);\n        }\n        state.autosaveTimer = setTimeout(() => {\n          state.autosaveTimer = null;\n          flushAutosave();\n        }, 1200);\n      }\n\n      async function flushAutosave() {\n        if (!state.autosaveDirty) {\n          return;\n        }\n        if (state.autosaveInFlight) {\n          state.autosaveQueued = true;\n          return;\n        }\n\n        state.autosaveInFlight = true;\n        state.autosaveDirty = false;\n        const saved = await saveScenario({ silent: true });\n        state.autosaveInFlight = false;\n\n        if (saved) {\n          if (state.autosaveHadError) {\n            log("Auto-save recovered.");\n          }\n          state.autosaveHadError = false;\n        } else {\n          state.autosaveDirty = true;\n          if (!state.autosaveHadError) {\n            log("Auto-save failed. Check project setup/permissions.", true);\n          }\n          state.autosaveHadError = true;\n        }\n\n        if (state.autosaveDirty || state.autosaveQueued) {\n          state.autosaveQueued = false;\n          scheduleAutosave();\n        }\n      }\n\n      function currentProjectRef() {\n        return state.projectId || (el.projectSlug.value || "").trim() || "default";\n      }\n\n      function inferAssetKindFromFile(file) {\n        const mime = String(file?.type || "").toLowerCase();\n        if (mime.startsWith("audio/")) {\n          return "music";\n        }\n        if (mime.startsWith("image/")) {\n          return "background";\n        }\n        return null;\n      }\n\n      async function uploadAssetFile(file, kind) {\n        if (!(file instanceof File)) {\n          return { ok: false, message: "No file selected." };\n        }\n        const ref = currentProjectRef();\n        const form = new FormData();\n        form.set("kind", kind);\n        form.set("file", file);\n        try {\n          const res = await fetch(\\`/api/projects/\\${encodeURIComponent(ref)}/assets\\`, {\n            method: "POST",\n            headers: headers({ json: false }),\n            body: form\n          });\n          const body = await res.json();\n          if (!res.ok || !body?.url) {\n            return { ok: false, message: \\`\\${body?.code ?? "UPLOAD_FAILED"}: \\${body?.message ?? "Asset upload failed."}\\` };\n          }\n          return { ok: true, url: body.url };\n        } catch (error) {\n          return { ok: false, message: \\`Asset upload failed: \\${error.message}\\` };\n        }\n      }\n\n      async function uploadSelectedAssetNodeFile(file) {\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node || node.type !== "asset") {\n          log("Select an asset node first.", true);\n          return;\n        }\n        const kind = inferAssetKindFromFile(file);\n        if (!kind) {\n          log("Only image/audio files are supported.", true);\n          return;\n        }\n        const result = await uploadAssetFile(file, kind);\n        if (!result.ok) {\n          log(result.message, true);\n          return;\n        }\n        el.assetKind.value = kind;\n        el.assetUrl.value = result.url;\n        if (!el.assetLabel.value.trim()) {\n          el.assetLabel.value = file.name || "asset";\n        }\n        applyNodeChanges({ silent: true });\n        log(\\`Asset uploaded: \\${file.name}\\`);\n      }\n\n      function applyAssetNodeToScene(assetNodeId, sceneNodeId, options = {}) {\n        const { silent = false } = options;\n        const assetNode = state.scenario.nodes.find((n) => n.id === assetNodeId);\n        const sceneNode = state.scenario.nodes.find((n) => n.id === sceneNodeId);\n        if (!assetNode || !sceneNode) {\n          return;\n        }\n        if (assetNode.type !== "asset") {\n          return;\n        }\n        if (sceneNode.type !== "scene") {\n          log("Asset node can only be dropped on a scene node.", true);\n          return;\n        }\n        const kind = assetNode.data?.assetKind;\n        const url = (assetNode.data?.url || "").trim();\n        if (!url) {\n          log("Asset node has no URL.", true);\n          return;\n        }\n\n        sceneNode.data = sceneNode.data || {};\n        sceneNode.data.assetLinks = sceneNode.data.assetLinks || {};\n        if (kind === "background") {\n          sceneNode.data.background = url;\n          sceneNode.data.assetLinks.background = assetNode.id;\n        } else if (kind === "character") {\n          const existingCharacters = getSceneCharacters(sceneNode);\n          const occupiedSlots = new Set(existingCharacters.map((character) => character.slot));\n          const slot = ["left", "center", "right"].find((candidate) => !occupiedSlots.has(candidate)) || "right";\n          const nextCharacters = existingCharacters.filter((character) => character.slot !== slot);\n          nextCharacters.push({ slot, image: url });\n          setSceneCharacters(sceneNode, nextCharacters);\n          delete sceneNode.data.characterImage;\n          const linkedCharacters = Array.isArray(sceneNode.data.assetLinks.character)\n            ? sceneNode.data.assetLinks.character.filter(Boolean)\n            : (sceneNode.data.assetLinks.character ? [sceneNode.data.assetLinks.character] : []);\n          if (!linkedCharacters.includes(assetNode.id)) {\n            linkedCharacters.push(assetNode.id);\n          }\n          sceneNode.data.assetLinks.character = linkedCharacters;\n        } else if (kind === "music") {\n          sceneNode.data.music = url;\n          sceneNode.data.assetLinks.music = assetNode.id;\n        } else {\n          log("Unsupported asset kind.", true);\n          return;\n        }\n\n        if (state.selectedNodeId === sceneNode.id) {\n          selectNode(sceneNode.id);\n        } else {\n          renderNodes();\n        }\n        persistDraft();\n        markScenarioDirty();\n        if (!silent) {\n          log(\\`Applied \\${kind} asset to \\${sceneNode.id}\\`);\n        }\n      }\n\n      function applyAssetNodeToScenes(assetNodeId, sceneIds) {\n        const uniqueSceneIds = [...new Set((sceneIds || []).filter(Boolean))];\n        if (uniqueSceneIds.length === 0) {\n          log("적용할 씬이 없습니다.", true);\n          return;\n        }\n        let applied = 0;\n        for (const sceneId of uniqueSceneIds) {\n          const sceneNode = state.scenario.nodes.find((n) => n.id === sceneId);\n          if (!sceneNode || sceneNode.type !== "scene") {\n            continue;\n          }\n          applyAssetNodeToScene(assetNodeId, sceneId, { silent: true });\n          applied += 1;\n        }\n        if (applied === 0) {\n          log("선택된 씬에 적용할 수 없습니다.", true);\n          return;\n        }\n        log(\\`Asset applied to \\${applied} scene node(s).\\`);\n      }\n\n      function ensureNodePosition(nodeId, fallbackIndex = 0) {\n        if (state.uiPositions[nodeId]) {\n          return state.uiPositions[nodeId];\n        }\n        const preferred = {\n          x: 24 + (fallbackIndex % 4) * 250,\n          y: 24 + Math.floor(fallbackIndex / 4) * 170\n        };\n        const position = findAvailableNodePosition(preferred, nodeId);\n        state.uiPositions[nodeId] = position;\n        return position;\n      }\n\n      function getEdgeList() {\n        const edges = [];\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene") {\n            const targets = getSceneTargets(node);\n            targets.forEach((to, index) => {\n              if (!to) return;\n              const label = targets.length >= 2 ? \\`opt\\${index + 1}\\` : "next";\n              edges.push({ from: node.id, to, label });\n            });\n          }\n        }\n        return edges;\n      }\n\n      function autoLayoutNodes() {\n        const nodes = state.scenario.nodes || [];\n        if (nodes.length === 0) {\n          return;\n        }\n\n        const adjacency = new Map();\n        for (const node of nodes) {\n          adjacency.set(node.id, []);\n        }\n        for (const edge of getEdgeList()) {\n          if (!adjacency.has(edge.from)) adjacency.set(edge.from, []);\n          adjacency.get(edge.from).push(edge.to);\n        }\n\n        const depthById = new Map();\n        const rootId = state.scenario.entryNodeId || nodes[0]?.id;\n        const queue = [];\n        if (rootId) {\n          depthById.set(rootId, 0);\n          queue.push(rootId);\n        }\n\n        while (queue.length > 0) {\n          const id = queue.shift();\n          const currentDepth = depthById.get(id) ?? 0;\n          for (const nextId of adjacency.get(id) || []) {\n            if (!depthById.has(nextId)) {\n              depthById.set(nextId, currentDepth + 1);\n              queue.push(nextId);\n            }\n          }\n        }\n\n        let fallbackDepth = 0;\n        for (const node of nodes) {\n          if (!depthById.has(node.id)) {\n            depthById.set(node.id, fallbackDepth + 1);\n            fallbackDepth += 1;\n          }\n        }\n\n        const lanes = new Map();\n        for (const node of nodes) {\n          const depth = depthById.get(node.id) ?? 0;\n          if (!lanes.has(depth)) lanes.set(depth, []);\n          lanes.get(depth).push(node.id);\n        }\n\n        const xGap = 280;\n        const yGap = 180;\n        for (const [depth, ids] of lanes.entries()) {\n          ids.forEach((id, rowIndex) => {\n            state.uiPositions[id] = {\n              x: 24 + depth * xGap,\n              y: 24 + rowIndex * yGap\n            };\n          });\n        }\n\n        renderNodes();\n        persistDraft();\n        log("Auto layout applied.");\n      }\n\n      function connectNodes(fromId, toId) {\n        const source = state.scenario.nodes.find((n) => n.id === fromId);\n        if (!source) {\n          return;\n        }\n        const target = state.scenario.nodes.find((n) => n.id === toId);\n        if (!target) {\n          return;\n        }\n        if (source.type !== "scene") {\n          log("Only scene nodes can connect to next nodes.", true);\n          return;\n        }\n        if (target.type !== "scene") {\n          log("Scene node can only connect to scene node.", true);\n          return;\n        }\n        const targets = getSceneTargets(source);\n        if (!targets.includes(toId)) {\n          targets.push(toId);\n        }\n        setSceneTargets(source, targets);\n        persistDraft();\n        markScenarioDirty();\n        if (state.selectedNodeId === source.id) {\n          selectNode(source.id);\n        } else {\n          renderNodes();\n        }\n        el.connectNode.textContent = "Connect (Drag)";\n        log(\\`Connected \\${fromId} -> \\${toId}\\`);\n      }\n\n      function canvasPointFromClient(clientX, clientY) {\n        const rect = el.nodeCanvas.getBoundingClientRect();\n        return {\n          x: clientX - rect.left + el.nodeCanvas.scrollLeft,\n          y: clientY - rect.top + el.nodeCanvas.scrollTop\n        };\n      }\n\n      function findNodeIdFromClient(clientX, clientY) {\n        const element = document.elementFromPoint(clientX, clientY);\n        const nodeEl = element?.closest?.(".node[data-node-id]");\n        if (!nodeEl) {\n          return null;\n        }\n        return nodeEl.getAttribute("data-node-id");\n      }\n\n      function getSelectedSceneIdsForAssetEdges() {\n        if (state.multiSelectedSceneIds.length > 0) {\n          return state.multiSelectedSceneIds.filter((id) => state.scenario.nodes.some((n) => n.id === id && n.type === "scene"));\n        }\n        if (state.selectedNodeId) {\n          const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n          if (node?.type === "scene") {\n            return [node.id];\n          }\n        }\n        return [];\n      }\n\n      function setMultiSceneSelection(ids) {\n        const sceneIds = new Set(\n          (ids || []).filter((id) => state.scenario.nodes.some((n) => n.id === id && n.type === "scene"))\n        );\n        state.multiSelectedSceneIds = [...sceneIds];\n      }\n\n      function toggleSceneSelection(id) {\n        if (!state.scenario.nodes.some((n) => n.id === id && n.type === "scene")) {\n          return;\n        }\n        const selected = new Set(state.multiSelectedSceneIds);\n        if (selected.has(id)) {\n          selected.delete(id);\n        } else {\n          selected.add(id);\n        }\n        state.multiSelectedSceneIds = [...selected];\n      }\n\n      function renderNodes() {\n        el.nodeCanvas.innerHTML = "";\n        const content = document.createElement("div");\n        content.className = "canvas-content";\n        el.nodeCanvas.appendChild(content);\n\n        const edgeLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg");\n        edgeLayer.setAttribute("class", "edge-layer");\n        content.appendChild(edgeLayer);\n\n        state.scenario.nodes.forEach((node, index) => ensureNodePosition(node.id, index));\n        const maxX = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.x ?? 0) + 260), 1200);\n        const maxY = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.y ?? 0) + 180), 900);\n        content.style.width = \\`\\${maxX}px\\`;\n        content.style.height = \\`\\${maxY}px\\`;\n\n        for (const edge of getEdgeList()) {\n          const fromPos = state.uiPositions[edge.from];\n          const toPos = state.uiPositions[edge.to];\n          if (!fromPos || !toPos) {\n            continue;\n          }\n          const x1 = fromPos.x + 220;\n          const y1 = fromPos.y + 46;\n          const x2 = toPos.x;\n          const y2 = toPos.y + 46;\n\n          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");\n          line.setAttribute("x1", String(x1));\n          line.setAttribute("y1", String(y1));\n          line.setAttribute("x2", String(x2));\n          line.setAttribute("y2", String(y2));\n          line.setAttribute("class", "edge-line");\n          edgeLayer.appendChild(line);\n\n          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");\n          label.setAttribute("x", String((x1 + x2) / 2));\n          label.setAttribute("y", String((y1 + y2) / 2 - 4));\n          label.setAttribute("class", "edge-label");\n          label.textContent = edge.label;\n          edgeLayer.appendChild(label);\n        }\n\n        const selectedScenesForAssetEdges = getSelectedSceneIdsForAssetEdges();\n        for (const sceneId of selectedScenesForAssetEdges) {\n          const sceneNode = state.scenario.nodes.find((n) => n.id === sceneId && n.type === "scene");\n          if (!sceneNode) continue;\n          const links = sceneNode.data?.assetLinks || {};\n          for (const [kind, assetNodeId] of Object.entries(links)) {\n            const linkedIds = Array.isArray(assetNodeId) ? assetNodeId : [assetNodeId];\n            for (const linkedId of linkedIds.filter(Boolean)) {\n              const assetNode = state.scenario.nodes.find((n) => n.id === linkedId && n.type === "asset");\n              if (!assetNode) continue;\n              const fromPos = state.uiPositions[sceneId];\n              const toPos = state.uiPositions[linkedId];\n              if (!fromPos || !toPos) continue;\n\n              const x1 = fromPos.x + 220;\n              const y1 = fromPos.y + 30;\n              const x2 = toPos.x;\n              const y2 = toPos.y + 30;\n\n              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");\n              line.setAttribute("x1", String(x1));\n              line.setAttribute("y1", String(y1));\n              line.setAttribute("x2", String(x2));\n              line.setAttribute("y2", String(y2));\n              line.setAttribute("class", "edge-line-asset");\n              edgeLayer.appendChild(line);\n\n              const label = document.createElementNS("http://www.w3.org/2000/svg", "text");\n              label.setAttribute("x", String((x1 + x2) / 2));\n              label.setAttribute("y", String((y1 + y2) / 2 - 6));\n              label.setAttribute("class", "edge-label-asset");\n              label.textContent = \\`asset:\\${kind}\\`;\n              edgeLayer.appendChild(label);\n            }\n          }\n        }\n\n        if (state.connectDrag) {\n          const fromPos = state.uiPositions[state.connectDrag.fromId];\n          if (fromPos) {\n            const x1 = fromPos.x + 220;\n            const y1 = fromPos.y + 46;\n            const x2 = state.connectDrag.x;\n            const y2 = state.connectDrag.y;\n            const preview = document.createElementNS("http://www.w3.org/2000/svg", "line");\n            preview.setAttribute("x1", String(x1));\n            preview.setAttribute("y1", String(y1));\n            preview.setAttribute("x2", String(x2));\n            preview.setAttribute("y2", String(y2));\n            preview.setAttribute("class", "edge-line");\n            preview.setAttribute("stroke-dasharray", "5 4");\n            edgeLayer.appendChild(preview);\n          }\n        }\n\n        if (state.marquee) {\n          const x = Math.min(state.marquee.x1, state.marquee.x2);\n          const y = Math.min(state.marquee.y1, state.marquee.y2);\n          const w = Math.abs(state.marquee.x2 - state.marquee.x1);\n          const h = Math.abs(state.marquee.y2 - state.marquee.y1);\n          const box = document.createElement("div");\n          box.className = "marquee-select";\n          box.style.left = \\`\\${x}px\\`;\n          box.style.top = \\`\\${y}px\\`;\n          box.style.width = \\`\\${w}px\\`;\n          box.style.height = \\`\\${h}px\\`;\n          content.appendChild(box);\n        }\n\n        for (const node of state.scenario.nodes) {\n          const div = document.createElement("div");\n          const isMultiSelectedScene = node.type === "scene" && state.multiSelectedSceneIds.includes(node.id);\n          const isSelected = state.selectedNodeId === node.id || state.connectFromId === node.id || isMultiSelectedScene;\n          const isDragging = state.draggingNodeId === node.id;\n          const isConnectTarget = state.connectHoverNodeId === node.id;\n          const isAssetDropTarget = state.assetDropNodeId === node.id;\n          const nodeTypeClass = node.type === "asset" ? "asset-node" : "scene-node";\n          div.className = \\`node \\${nodeTypeClass} \\${isSelected ? "selected" : ""} \\${isDragging ? "dragging" : ""} \\${isConnectTarget ? "connect-target" : ""} \\${isAssetDropTarget ? "asset-drop-target" : ""}\\`;\n          div.setAttribute("data-node-id", node.id);\n          const pos = state.uiPositions[node.id];\n          div.style.left = \\`\\${pos.x}px\\`;\n          div.style.top = \\`\\${pos.y}px\\`;\n          const sceneTargets = node.type === "scene" ? getSceneTargets(node) : [];\n          const sceneState = node.type === "scene"\n            ? (sceneTargets.length === 0 ? "ending" : (sceneTargets.length >= 2 ? "option" : "normal"))\n            : "-";\n          const nodePreview = node.type === "asset"\n            ? (node.data?.label || node.data?.url || "(asset)")\n            : (node.data?.text || "(no text)");\n          const nodeNextDisplay = node.type === "scene" ? (sceneTargets[0] || "-") : "-";\n          const nodeAssetDisplay = node.type === "asset"\n            ? \\`\\${node.data?.assetKind || "-"}:\\${node.data?.url ? "y" : "-"}\\`\n            : "-";\n          div.innerHTML = \\`\n            <div class="node-meta"><span>\\${node.id}</span><span>\\${node.type}</span></div>\n            <div class="node-text">\\${nodePreview}</div>\n            <div class="node-row">\n              <span class="mono">next: \\${nodeNextDisplay} / scene:\\${sceneState} / asset:\\${nodeAssetDisplay}</span>\n              <span class="connect-handle" data-role="connect-handle" title="Drag to connect/apply"></span>\n            </div>\n            <div class="mono">bg:\\${node.data?.background ? "y" : "-"} char:\\${getSceneCharacters(node).length > 0 || node.data?.characterImage ? "y" : "-"} bgm:\\${node.data?.music ? "y" : "-"} spd:\\${Number.isFinite(Number(node.data?.textSpeed)) ? Math.round(Number(node.data?.textSpeed)) : "-"}</div>\n          \\`;\n          div.onpointerdown = (event) => {\n            const isHandle = event.target?.closest?.("[data-role=\'connect-handle\']");\n            if (isHandle) {\n              event.preventDefault();\n              event.stopPropagation();\n              state.connectDrag = {\n                fromId: node.id,\n                ...canvasPointFromClient(event.clientX, event.clientY)\n              };\n              state.connectHoverNodeId = null;\n              state.connectFromId = node.id;\n              const onMove = (moveEvent) => {\n                state.connectDrag = {\n                  fromId: node.id,\n                  ...canvasPointFromClient(moveEvent.clientX, moveEvent.clientY)\n                };\n                const hovered = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);\n                state.connectHoverNodeId = hovered && hovered !== node.id ? hovered : null;\n                renderNodes();\n              };\n              const onUp = () => {\n                window.removeEventListener("pointermove", onMove);\n                window.removeEventListener("pointerup", onUp);\n                if (state.connectHoverNodeId && state.connectHoverNodeId !== node.id) {\n                  if (node.type === "scene") {\n                    connectNodes(node.id, state.connectHoverNodeId);\n                  } else if (node.type === "asset") {\n                    const selectedScenes = state.multiSelectedSceneIds.length > 0\n                      ? state.multiSelectedSceneIds\n                      : (state.lastSelectedSceneId ? [state.lastSelectedSceneId] : []);\n                    if (selectedScenes.length > 0) {\n                      applyAssetNodeToScenes(node.id, selectedScenes);\n                    } else {\n                      applyAssetNodeToScene(node.id, state.connectHoverNodeId);\n                    }\n                  }\n                }\n                state.connectDrag = null;\n                state.connectHoverNodeId = null;\n                state.connectFromId = null;\n                renderNodes();\n              };\n              window.addEventListener("pointermove", onMove);\n              window.addEventListener("pointerup", onUp);\n              return;\n            }\n\n            event.preventDefault();\n            state.draggingNodeId = node.id;\n            const start = canvasPointFromClient(event.clientX, event.clientY);\n            const origin = { ...state.uiPositions[node.id] };\n            const toggleMulti = Boolean(event.ctrlKey || event.metaKey);\n            let dragged = false;\n            let lastClientX = event.clientX;\n            let lastClientY = event.clientY;\n            const onMove = (moveEvent) => {\n              lastClientX = moveEvent.clientX;\n              lastClientY = moveEvent.clientY;\n              const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);\n              const dx = current.x - start.x;\n              const dy = current.y - start.y;\n              if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {\n                dragged = true;\n              }\n              state.uiPositions[node.id] = {\n                x: Math.max(8, origin.x + dx),\n                y: Math.max(8, origin.y + dy)\n              };\n              const hoveredNodeId = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);\n              state.assetDropNodeId = hoveredNodeId && hoveredNodeId !== node.id ? hoveredNodeId : null;\n              renderNodes();\n            };\n            const onUp = () => {\n              window.removeEventListener("pointermove", onMove);\n              window.removeEventListener("pointerup", onUp);\n              state.draggingNodeId = null;\n              state.assetDropNodeId = null;\n              if (dragged) {\n                persistDraft();\n              } else {\n                if (node.type !== "scene") {\n                  selectNode(node.id, { preserveMulti: true });\n                } else if (toggleMulti) {\n                  toggleSceneSelection(node.id);\n                  selectNode(node.id, { preserveMulti: true });\n                } else {\n                  selectNode(node.id);\n                }\n              }\n              renderNodes();\n            };\n            window.addEventListener("pointermove", onMove);\n            window.addEventListener("pointerup", onUp);\n          };\n          content.appendChild(div);\n        }\n\n        const startMarqueeSelection = (event) => {\n          if (event.target?.closest?.(".node")) {\n            return;\n          }\n          if (event.button !== 0) {\n            return;\n          }\n          event.preventDefault();\n          const start = canvasPointFromClient(event.clientX, event.clientY);\n          const additive = Boolean(event.ctrlKey || event.metaKey);\n          const baseSelection = additive ? new Set(state.multiSelectedSceneIds) : new Set();\n          state.marquee = { x1: start.x, y1: start.y, x2: start.x, y2: start.y };\n          renderNodes();\n\n          const onMove = (moveEvent) => {\n            const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);\n            state.marquee = { x1: start.x, y1: start.y, x2: current.x, y2: current.y };\n            renderNodes();\n          };\n\n          const onUp = () => {\n            window.removeEventListener("pointermove", onMove);\n            window.removeEventListener("pointerup", onUp);\n            const marquee = state.marquee;\n            state.marquee = null;\n            if (!marquee) {\n              renderNodes();\n              return;\n            }\n            const x1 = Math.min(marquee.x1, marquee.x2);\n            const y1 = Math.min(marquee.y1, marquee.y2);\n            const x2 = Math.max(marquee.x1, marquee.x2);\n            const y2 = Math.max(marquee.y1, marquee.y2);\n            const isClick = Math.abs(marquee.x2 - marquee.x1) < 4 && Math.abs(marquee.y2 - marquee.y1) < 4;\n\n            if (isClick) {\n              if (!additive) {\n                setMultiSceneSelection([]);\n              }\n              renderNodes();\n              return;\n            }\n\n            const selectedByBox = state.scenario.nodes\n              .filter((n) => n.type === "scene")\n              .filter((n) => {\n                const p = state.uiPositions[n.id];\n                if (!p) return false;\n                const nx1 = p.x;\n                const ny1 = p.y;\n                const nx2 = p.x + 220;\n                const ny2 = p.y + 130;\n                return nx1 <= x2 && nx2 >= x1 && ny1 <= y2 && ny2 >= y1;\n              })\n              .map((n) => n.id);\n\n            const merged = new Set(baseSelection);\n            selectedByBox.forEach((id) => merged.add(id));\n            setMultiSceneSelection([...merged]);\n            if (state.multiSelectedSceneIds.length === 1) {\n              selectNode(state.multiSelectedSceneIds[0], { preserveMulti: true });\n            } else {\n              renderNodes();\n            }\n          };\n\n          window.addEventListener("pointermove", onMove);\n          window.addEventListener("pointerup", onUp);\n        };\n        content.onpointerdown = startMarqueeSelection;\n        el.nodeCanvas.onpointerdown = startMarqueeSelection;\n      }\n\n      function setFieldVisible(element, visible) {\n        element.classList.toggle("hidden", !visible);\n      }\n\n      function updateNodeFormByType(node) {\n        const isScene = node?.type === "scene";\n        const isAsset = node?.type === "asset";\n        el.nodeTextLabel.textContent = "Node Text";\n        setFieldVisible(el.nodeTextField, isScene);\n        setFieldVisible(el.nodeSpeakerField, isScene);\n        setFieldVisible(el.nodeTextSpeedField, isScene);\n        setFieldVisible(el.nodeNextField, false);\n        setFieldVisible(el.assetKindField, isAsset);\n        setFieldVisible(el.assetLabelField, isAsset);\n        setFieldVisible(el.assetUrlField, isAsset);\n        setFieldVisible(el.assetUpload, isAsset);\n        setFieldVisible(el.applyAssetToLastScene, isAsset);\n        setFieldVisible(el.nodeBackground.parentElement, isScene);\n        setFieldVisible(el.nodeCharacterLeft.parentElement, isScene);\n        setFieldVisible(el.nodeCharacterCenter.parentElement, isScene);\n        setFieldVisible(el.nodeCharacterRight.parentElement, isScene);\n        setFieldVisible(el.nodeMusic.parentElement, isScene);\n      }\n\n      function selectNode(id, options = {}) {\n        const { preserveMulti = false } = options;\n        state.selectedNodeId = id;\n        const node = state.scenario.nodes.find((n) => n.id === id);\n        if (!node) return;\n        if (!preserveMulti) {\n          if (node.type === "scene") {\n            setMultiSceneSelection([node.id]);\n          } else {\n            setMultiSceneSelection([]);\n          }\n        }\n        if (node.type === "scene") {\n          state.lastSelectedSceneId = node.id;\n        }\n        updateNodeFormByType(node);\n        el.selectedNodeLabel.textContent = \\`\\${node.id} (\\${node.type})\\`;\n        if (node.type === "asset") {\n          el.nodeText.value = "";\n          el.nodeSpeaker.value = "";\n          el.nodeTextSpeed.value = "";\n          el.nodeNext.value = "";\n          el.assetKind.value = node.data?.assetKind || "background";\n          el.assetLabel.value = node.data?.label || "";\n          el.assetUrl.value = node.data?.url || "";\n        } else {\n          const sceneTargets = getSceneTargets(node);\n          el.nodeText.value = node.data?.text ?? "";\n          el.nodeSpeaker.value = node.data?.speaker ?? "";\n          el.nodeTextSpeed.value = Number.isFinite(Number(node.data?.textSpeed)) ? String(Math.round(Number(node.data?.textSpeed))) : "";\n          el.nodeNext.value = sceneTargets[0] ?? "";\n          el.assetKind.value = "background";\n          el.assetLabel.value = "";\n          el.assetUrl.value = "";\n        }\n        el.nodeBackground.value = node.data?.background ?? "";\n        const characters = getSceneCharacters(node);\n        el.nodeCharacterLeft.value = characters.find((character) => character.slot === "left")?.image || "";\n        el.nodeCharacterCenter.value = characters.find((character) => character.slot === "center")?.image || "";\n        el.nodeCharacterRight.value = characters.find((character) => character.slot === "right")?.image || "";\n        el.nodeMusic.value = node.data?.music ?? "";\n        renderNodes();\n      }\n\n      function applySelectedAssetToLastScene() {\n        const assetNode = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!assetNode || assetNode.type !== "asset") {\n          log("Select an asset node first.", true);\n          return;\n        }\n        const selectedScenes = state.multiSelectedSceneIds.length > 0\n          ? state.multiSelectedSceneIds\n          : (state.lastSelectedSceneId ? [state.lastSelectedSceneId] : []);\n        if (selectedScenes.length === 0) {\n          log("적용할 씬을 먼저 선택하세요.", true);\n          return;\n        }\n        applyAssetNodeToScenes(assetNode.id, selectedScenes);\n      }\n\n      function getSceneTargets(node) {\n        if (!node || node.type !== "scene") {\n          return [];\n        }\n        const stored = Array.isArray(node.data?.targets) ? node.data.targets.filter(Boolean) : [];\n        if (stored.length > 0) {\n          return [...new Set(stored)];\n        }\n        return node.next ? [node.next] : [];\n      }\n\n      function setSceneTargets(node, targets) {\n        if (!node || node.type !== "scene") {\n          return;\n        }\n        const unique = [...new Set((targets || []).filter(Boolean))];\n        node.data = node.data || {};\n        node.data.targets = unique;\n        node.next = unique[0] || null;\n      }\n\n      function applyNodeChanges(options = {}) {\n        const { silent = true } = options;\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node) return;\n        node.data = node.data || {};\n        const speaker = (el.nodeSpeaker.value || "").trim();\n        const textSpeedInput = (el.nodeTextSpeed.value || "").trim();\n        const background = (el.nodeBackground.value || "").trim();\n        const characterLeft = (el.nodeCharacterLeft.value || "").trim();\n        const characterCenter = (el.nodeCharacterCenter.value || "").trim();\n        const characterRight = (el.nodeCharacterRight.value || "").trim();\n        const music = (el.nodeMusic.value || "").trim();\n        const assetKind = (el.assetKind.value || "background").trim();\n        const assetLabel = (el.assetLabel.value || "").trim();\n        const assetUrl = (el.assetUrl.value || "").trim();\n        if (node.type === "scene") {\n          node.data.text = el.nodeText.value;\n          const sceneTargets = getSceneTargets(node);\n          setSceneTargets(node, sceneTargets);\n          if (speaker) {\n            node.data.speaker = speaker;\n          } else {\n            delete node.data.speaker;\n          }\n          if (textSpeedInput === "") {\n            delete node.data.textSpeed;\n          } else {\n            const rawSpeed = Number(textSpeedInput);\n            if (Number.isFinite(rawSpeed)) {\n              node.data.textSpeed = Math.max(0, Math.min(96, Math.round(rawSpeed)));\n            }\n          }\n          delete node.data.assetKind;\n          delete node.data.label;\n          delete node.data.url;\n        } else if (node.type === "asset") {\n          node.data.assetKind = ["background", "character", "music"].includes(assetKind) ? assetKind : "background";\n          node.data.label = assetLabel || "asset";\n          node.data.url = assetUrl;\n          delete node.next;\n          delete node.data.text;\n          delete node.data.speaker;\n          delete node.data.textSpeed;\n          delete node.data.background;\n          delete node.data.characters;\n          delete node.data.characterImage;\n          delete node.data.music;\n        } else {\n          delete node.data.textSpeed;\n        }\n        if (node.type === "scene") {\n          if (background) {\n            node.data.background = background;\n          } else {\n            delete node.data.background;\n          }\n          setSceneCharacters(node, [\n            { slot: "left", image: characterLeft },\n            { slot: "center", image: characterCenter },\n            { slot: "right", image: characterRight }\n          ]);\n          delete node.data.characterImage;\n          if (music) {\n            node.data.music = music;\n          } else {\n            delete node.data.music;\n          }\n        }\n        renderNodes();\n        persistDraft();\n        markScenarioDirty();\n        if (!silent) {\n          log(\\`Applied changes to \\${node.id}\\`);\n        }\n      }\n\n      function deleteSelectedNode() {\n        if (!state.selectedNodeId) {\n          log("No selected node to delete.", true);\n          return;\n        }\n        if (state.scenario.nodes.length <= 1) {\n          log("Cannot delete the last node.", true);\n          return;\n        }\n\n        const removeId = state.selectedNodeId;\n        state.scenario.nodes = state.scenario.nodes.filter((n) => n.id !== removeId);\n        delete state.uiPositions[removeId];\n        if (state.connectFromId === removeId) {\n          state.connectFromId = null;\n        }\n\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene") {\n            const targets = getSceneTargets(node).filter((id) => id !== removeId);\n            setSceneTargets(node, targets);\n            if (node.data?.assetLinks && typeof node.data.assetLinks === "object") {\n              for (const [kind, linkedId] of Object.entries(node.data.assetLinks)) {\n                if (linkedId === removeId) {\n                  delete node.data.assetLinks[kind];\n                } else if (Array.isArray(linkedId)) {\n                  const filtered = linkedId.filter((id) => id !== removeId);\n                  if (filtered.length > 0) {\n                    node.data.assetLinks[kind] = filtered;\n                  } else {\n                    delete node.data.assetLinks[kind];\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (state.scenario.entryNodeId === removeId) {\n          state.scenario.entryNodeId = state.scenario.nodes[0]?.id ?? null;\n        }\n        state.selectedNodeId = state.scenario.entryNodeId ?? state.scenario.nodes[0]?.id ?? null;\n        renderNodes();\n        if (state.selectedNodeId) {\n          selectNode(state.selectedNodeId);\n        }\n        persistDraft();\n        markScenarioDirty();\n        log(\\`Deleted node \\${removeId}\\`);\n      }\n\n      function addNode(type, payload = null) {\n        const id = \\`n_\\${type}_\\${Math.random().toString(36).slice(2, 6)}\\`;\n        const node = { id, type, data: {} };\n        let previousLinkedTargetId = null;\n        if (type === "scene") {\n          node.data.text = "새 장면";\n          node.data.textSpeed = 24;\n          setSceneTargets(node, []);\n        }\n        if (type === "asset") {\n          node.data.assetKind = payload?.assetKind || "background";\n          node.data.label = payload?.label || "asset";\n          node.data.url = payload?.url || "";\n        }\n        const selectedIndex = state.scenario.nodes.findIndex((n) => n.id === state.selectedNodeId);\n        const selectedNode = selectedIndex >= 0 ? state.scenario.nodes[selectedIndex] : null;\n\n        if (type === "scene" && selectedNode) {\n          state.scenario.nodes.splice(selectedIndex + 1, 0, node);\n          if (selectedNode.type === "scene") {\n            const selectedTargets = getSceneTargets(selectedNode);\n            previousLinkedTargetId = selectedTargets[0] ?? null;\n            const restTargets = selectedTargets.slice(1);\n            setSceneTargets(selectedNode, [id, ...restTargets]);\n            setSceneTargets(node, previousLinkedTargetId ? [previousLinkedTargetId] : []);\n          }\n        } else if (selectedNode) {\n          state.scenario.nodes.splice(selectedIndex + 1, 0, node);\n        } else {\n          state.scenario.nodes.push(node);\n        }\n\n        if (type === "scene" && selectedNode && previousLinkedTargetId) {\n          const newNodeIndex = state.scenario.nodes.findIndex((n) => n.id === id);\n          const linkedNodeIndex = state.scenario.nodes.findIndex((n) => n.id === previousLinkedTargetId);\n          if (newNodeIndex >= 0 && linkedNodeIndex >= 0 && linkedNodeIndex !== newNodeIndex + 1) {\n            const [linkedNode] = state.scenario.nodes.splice(linkedNodeIndex, 1);\n            const insertIndex = state.scenario.nodes.findIndex((n) => n.id === id) + 1;\n            state.scenario.nodes.splice(insertIndex, 0, linkedNode);\n          }\n        }\n\n        if (selectedNode && state.uiPositions[selectedNode.id]) {\n          const selectedPos = state.uiPositions[selectedNode.id];\n          const preferred = {\n            x: selectedPos.x + 250,\n            y: selectedPos.y\n          };\n          state.uiPositions[id] = findAvailableNodePosition(preferred, id);\n\n          if (type === "scene" && previousLinkedTargetId && state.uiPositions[previousLinkedTargetId]) {\n            const linkedPos = state.uiPositions[previousLinkedTargetId];\n            if (linkedPos.x === state.uiPositions[id].x && linkedPos.y === state.uiPositions[id].y) {\n              state.uiPositions[previousLinkedTargetId] = {\n                x: linkedPos.x + 250,\n                y: linkedPos.y\n              };\n            }\n          }\n        }\n\n        renderNodes();\n        if (type === "scene") {\n          selectNode(id);\n        } else {\n          renderNodes();\n        }\n        persistDraft();\n        markScenarioDirty();\n      }\n\n      async function createProject() {\n        const res = await fetch("/api/projects", {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            name: el.projectName.value,\n            slug: el.projectSlug.value\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.projectId = body.project?.id || state.projectId;\n          el.projectStatus.textContent = \\`project: \\${body.project?.id ?? "created"} (\\${body.correlationId})\\`;\n          persistDraft();\n          markScenarioDirty();\n          log("Project created.");\n        } else {\n          el.projectStatus.textContent = \\`\\${body.code}: \\${body.message}\\`;\n          log(\\`\\${body.code} \\${body.message}\\`, true);\n        }\n      }\n\n      async function saveScenario(options = {}) {\n        const { silent = false } = options;\n        const res = await fetch(\\`/api/projects/\\${state.projectId}/scenario\\`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            requestedVersion: state.scenarioVersion,\n            currentVersion: state.scenarioVersion,\n            content: state.scenario\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.scenarioVersion = body.nextVersion;\n          state.autosaveDirty = false;\n          state.autosaveQueued = false;\n          state.autosaveHadError = false;\n          persistDraft();\n          if (!silent) {\n            log(\\`Scenario saved. version=\\${state.scenarioVersion}\\`);\n          }\n          return true;\n        } else {\n          if (!silent) {\n            log(\\`\\${body.code} \\${body.message}\\`, true);\n          }\n          return false;\n        }\n      }\n\n      async function validateScenario() {\n        const res = await fetch(\\`/api/projects/\\${state.projectId}/validate\\`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ scenario: state.scenario })\n        });\n        const body = await res.json();\n        const issues = body.issues || body.details?.errors || [];\n        el.issues.innerHTML = "";\n        el.issueCount.textContent = String(issues.length);\n        issues.forEach((issue) => {\n          const div = document.createElement("div");\n          div.className = "issue";\n          div.innerHTML = \\`<strong>\\${issue.code}</strong> \\${issue.message}\\`;\n          el.issues.appendChild(div);\n        });\n        if (res.ok) {\n          log("Validation passed.");\n        } else {\n          log(\\`\\${body.code} (\\${issues.length} issues)\\`, true);\n        }\n      }\n\n      async function buildSeo() {\n        const res = await fetch(\\`/api/projects/\\${state.projectId}/build\\`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ jobType: "seo" })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          log(\\`Build queued (\\${body.jobType})\\`);\n        } else {\n          log(\\`\\${body.code}: \\${body.message}\\`, true);\n        }\n      }\n\n      async function openPlayer() {\n        const projectRef = state.projectId || el.projectSlug.value?.trim();\n        if (!projectRef) {\n          log("No project id/slug available for player test.", true);\n          return;\n        }\n        const saved = await saveScenario({ silent: true });\n        if (!saved) {\n          log("Play Test aborted: scenario save failed.", true);\n          return;\n        }\n        const target = \\`\\${playerBaseUrl}/play/\\${encodeURIComponent(projectRef)}\\`;\n        window.open(target, "_blank", "noopener,noreferrer");\n        log(\\`Opened player test: \\${projectRef}\\`);\n      }\n\n      function toggleConnectMode() {\n        log("Drag scene node onto scene node to connect next. Drag asset node onto scene node to apply asset.");\n      }\n\n      el.createProjectBtn.onclick = createProject;\n      el.addScene.onclick = () => addNode("scene");\n      el.addAsset.onclick = () => addNode("asset");\n      el.autoLayout.onclick = autoLayoutNodes;\n      el.saveScenario.onclick = saveScenario;\n      el.validateScenario.onclick = validateScenario;\n      el.connectNode.onclick = toggleConnectMode;\n      el.buildSeo.onclick = buildSeo;\n      el.openPlayer.onclick = openPlayer;\n      el.deleteNode.onclick = deleteSelectedNode;\n      el.assetUpload.onclick = () => el.assetUploadFile.click();\n      el.applyAssetToLastScene.onclick = applySelectedAssetToLastScene;\n      el.assetUploadFile.addEventListener("change", () => {\n        const file = el.assetUploadFile.files?.[0];\n        if (file) {\n          uploadSelectedAssetNodeFile(file);\n        }\n        el.assetUploadFile.value = "";\n      });\n      el.projectName.addEventListener("change", persistDraft);\n      el.projectSlug.addEventListener("change", persistDraft);\n      el.assetKind.addEventListener("change", () => applyNodeChanges({ silent: true }));\n      [el.nodeText, el.nodeSpeaker, el.nodeTextSpeed, el.nodeNext, el.nodeBackground, el.nodeCharacterLeft, el.nodeCharacterCenter, el.nodeCharacterRight, el.nodeMusic, el.assetKind, el.assetLabel, el.assetUrl].forEach((input) => {\n        input.addEventListener("input", () => applyNodeChanges({ silent: true }));\n      });\n\n      restoreDraft();\n      normalizeScenarioNodeTypes();\n      renderNodes();\n      selectNode(state.scenario.entryNodeId || "n_start");\n    </script> </body> </html>'])), renderHead(), defineScriptVars({ defaultScenario, playerBaseUrl }));
}, "/Users/uiwwsw/visual-novel/apps/studio/src/pages/index.astro", void 0);
const $$file = "/Users/uiwwsw/visual-novel/apps/studio/src/pages/index.astro";
const $$url = "";

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$Index,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

const page = () => _page;

export { page };
