import { e as createComponent, r as renderTemplate, k as defineScriptVars, l as renderHead } from '../chunks/astro/server_BWx0qOMJ.mjs';
import 'piccolore';
import 'clsx';
/* empty css                                 */
export { renderers } from '../renderers.mjs';

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const defaultScenario = {
    meta: { schemaVersion: "1.0.0", title: "New VN" },
    entryNodeId: "n_start",
    nodes: [
      { id: "n_start", type: "scene", next: "n_end", data: { text: "첫 장면입니다." } },
      { id: "n_end", type: "ending", data: { endingId: "end_1", title: "엔딩" } }
    ]
  };
  const playerBaseUrl = "http://localhost:4322";
  return renderTemplate(_a || (_a = __template(['<html lang="ko" data-astro-cid-j7pv25f6> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>VN Studio</title>', '</head> <body data-astro-cid-j7pv25f6> <main class="layout" data-astro-cid-j7pv25f6> <section class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h1 data-astro-cid-j7pv25f6>PIXEL VN STUDIO</h1> <h3 data-astro-cid-j7pv25f6>Project + Scenario Authoring</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label data-astro-cid-j7pv25f6>Project Name <input id="projectName" value="My VN" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Project Slug <input id="projectSlug" value="my-vn" data-astro-cid-j7pv25f6></label> <button class="primary" id="createProjectBtn" data-astro-cid-j7pv25f6>Create Project</button> <div id="projectStatus" class="mono" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="group stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTOR CONTEXT</h2> <label data-astro-cid-j7pv25f6>Role\n<select id="role" data-astro-cid-j7pv25f6> <option value="owner" data-astro-cid-j7pv25f6>owner</option> <option value="editor" selected data-astro-cid-j7pv25f6>editor</option> <option value="viewer" data-astro-cid-j7pv25f6>viewer</option> </select> </label> <label data-astro-cid-j7pv25f6>Plan\n<select id="plan" data-astro-cid-j7pv25f6> <option value="free" selected data-astro-cid-j7pv25f6>free</option> <option value="pro" data-astro-cid-j7pv25f6>pro</option> </select> </label> <label data-astro-cid-j7pv25f6>User ID <input id="userId" value="00000000-0000-0000-0000-000000000010" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Org ID <input id="orgId" value="00000000-0000-0000-0000-000000000020" data-astro-cid-j7pv25f6></label> </div> </section> <section class="panel editor-panel" data-astro-cid-j7pv25f6> <div class="toolbar" data-astro-cid-j7pv25f6> <button id="addScene" data-astro-cid-j7pv25f6>+ Scene</button> <button id="addChoice" data-astro-cid-j7pv25f6>+ Choice</button> <button id="addEnding" data-astro-cid-j7pv25f6>+ Ending</button> <button id="saveScenario" class="primary" data-astro-cid-j7pv25f6>Save Scenario</button> <button id="validateScenario" data-astro-cid-j7pv25f6>Validate</button> <button id="connectNode" data-astro-cid-j7pv25f6>Connect (Drag)</button> <button id="buildSeo" class="warn" data-astro-cid-j7pv25f6>Build SEO</button> <button id="openPlayer" data-astro-cid-j7pv25f6>Play Test</button> </div> <div class="canvas" id="nodeCanvas" data-astro-cid-j7pv25f6></div> </section> <aside class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>NODE PROPERTIES</h2> <h3 id="selectedNodeLabel" data-astro-cid-j7pv25f6>No node selected</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label id="nodeTextField" data-astro-cid-j7pv25f6><span id="nodeTextLabel" data-astro-cid-j7pv25f6>Node Text</span> <textarea id="nodeText" rows="5" placeholder="scene text" data-astro-cid-j7pv25f6></textarea> </label> <label id="nodeSpeakerField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Character Name</span> <input id="nodeSpeaker" placeholder="Narrator" data-astro-cid-j7pv25f6> </label> <label id="nodeTextSpeedField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Text Speed (ms, 0 = instant)</span> <input id="nodeTextSpeed" type="number" min="0" max="96" step="1" placeholder="24" data-astro-cid-j7pv25f6> </label> <label id="nodeNextField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Next Node ID</span> <input id="nodeNext" placeholder="n_end" data-astro-cid-j7pv25f6> </label> <div id="choiceOptionsField" class="hidden" data-astro-cid-j7pv25f6> <span data-astro-cid-j7pv25f6>Choice Options</span> <div id="choiceOptionsEditor" class="choice-options" data-astro-cid-j7pv25f6></div> <button id="addChoiceOption" data-astro-cid-j7pv25f6>+ Option</button> </div> <label data-astro-cid-j7pv25f6>Background URL\n<input id="nodeBackground" placeholder="/assets/bg/school.jpg" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Image URL\n<input id="nodeCharacterImage" placeholder="/assets/char/hero.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>BGM URL\n<input id="nodeMusic" placeholder="/assets/bgm/theme.mp3" data-astro-cid-j7pv25f6> </label> <button id="deleteNode" class="warn" data-astro-cid-j7pv25f6>Delete Node</button> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>VALIDATION ISSUES <span id="issueCount" class="badge" data-astro-cid-j7pv25f6>0</span></h2> <div id="issues" class="issues" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTIVITY</h2> <div id="activity" class="mono" data-astro-cid-j7pv25f6></div> </div> </aside> </main> <script type="module">', '\n      const state = {\n        projectId: "p1",\n        scenarioVersion: 1,\n        selectedNodeId: null,\n        connectFromId: null,\n        draggingNodeId: null,\n        connectDrag: null,\n        connectHoverNodeId: null,\n        scenario: structuredClone(defaultScenario),\n        uiPositions: {}\n      };\n\n      const el = {\n        projectName: document.getElementById("projectName"),\n        projectSlug: document.getElementById("projectSlug"),\n        createProjectBtn: document.getElementById("createProjectBtn"),\n        projectStatus: document.getElementById("projectStatus"),\n        role: document.getElementById("role"),\n        plan: document.getElementById("plan"),\n        userId: document.getElementById("userId"),\n        orgId: document.getElementById("orgId"),\n        nodeCanvas: document.getElementById("nodeCanvas"),\n        selectedNodeLabel: document.getElementById("selectedNodeLabel"),\n        nodeTextField: document.getElementById("nodeTextField"),\n        nodeTextLabel: document.getElementById("nodeTextLabel"),\n        nodeText: document.getElementById("nodeText"),\n        nodeSpeakerField: document.getElementById("nodeSpeakerField"),\n        nodeSpeaker: document.getElementById("nodeSpeaker"),\n        nodeTextSpeedField: document.getElementById("nodeTextSpeedField"),\n        nodeTextSpeed: document.getElementById("nodeTextSpeed"),\n        nodeNextField: document.getElementById("nodeNextField"),\n        nodeNext: document.getElementById("nodeNext"),\n        choiceOptionsField: document.getElementById("choiceOptionsField"),\n        choiceOptionsEditor: document.getElementById("choiceOptionsEditor"),\n        addChoiceOption: document.getElementById("addChoiceOption"),\n        nodeBackground: document.getElementById("nodeBackground"),\n        nodeCharacterImage: document.getElementById("nodeCharacterImage"),\n        nodeMusic: document.getElementById("nodeMusic"),\n        deleteNode: document.getElementById("deleteNode"),\n        addScene: document.getElementById("addScene"),\n        addChoice: document.getElementById("addChoice"),\n        addEnding: document.getElementById("addEnding"),\n        saveScenario: document.getElementById("saveScenario"),\n        validateScenario: document.getElementById("validateScenario"),\n        connectNode: document.getElementById("connectNode"),\n        buildSeo: document.getElementById("buildSeo"),\n        openPlayer: document.getElementById("openPlayer"),\n        issues: document.getElementById("issues"),\n        issueCount: document.getElementById("issueCount"),\n        activity: document.getElementById("activity")\n      };\n\n      function headers() {\n        return {\n          "content-type": "application/json",\n          "x-user-role": el.role.value,\n          "x-plan-tier": el.plan.value,\n          "x-user-id": el.userId.value,\n          "x-org-id": el.orgId.value\n        };\n      }\n\n      function draftKey() {\n        const ref = state.projectId || el.projectSlug.value || "default";\n        return `vn.studio.draft.${ref}`;\n      }\n\n      function persistDraft() {\n        const snapshot = {\n          projectId: state.projectId,\n          scenarioVersion: state.scenarioVersion,\n          scenario: state.scenario,\n          uiPositions: state.uiPositions,\n          projectName: el.projectName.value,\n          projectSlug: el.projectSlug.value\n        };\n        localStorage.setItem(draftKey(), JSON.stringify(snapshot));\n      }\n\n      function restoreDraft() {\n        const currentRef = state.projectId || el.projectSlug.value;\n        if (!currentRef) {\n          return;\n        }\n        const raw = localStorage.getItem(`vn.studio.draft.${currentRef}`);\n        if (!raw) {\n          return;\n        }\n        try {\n          const parsed = JSON.parse(raw);\n          if (parsed.projectId) state.projectId = parsed.projectId;\n          if (Number.isInteger(parsed.scenarioVersion)) state.scenarioVersion = parsed.scenarioVersion;\n          if (parsed.projectName) el.projectName.value = parsed.projectName;\n          if (parsed.projectSlug) el.projectSlug.value = parsed.projectSlug;\n          if (parsed.scenario?.entryNodeId && Array.isArray(parsed.scenario?.nodes)) {\n            state.scenario = parsed.scenario;\n          }\n          if (parsed.uiPositions && typeof parsed.uiPositions === "object") {\n            state.uiPositions = parsed.uiPositions;\n          }\n          log("Draft restored from local storage.");\n        } catch (error) {\n          log(`Draft restore failed: ${error.message}`, true);\n        }\n      }\n\n      function log(message, error = false) {\n        const line = document.createElement("div");\n        line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;\n        line.className = error ? "error" : "ok";\n        el.activity.prepend(line);\n      }\n\n      function ensureNodePosition(nodeId, fallbackIndex = 0) {\n        if (state.uiPositions[nodeId]) {\n          return state.uiPositions[nodeId];\n        }\n        const position = {\n          x: 24 + (fallbackIndex % 4) * 250,\n          y: 24 + Math.floor(fallbackIndex / 4) * 170\n        };\n        state.uiPositions[nodeId] = position;\n        return position;\n      }\n\n      function getEdgeList() {\n        const edges = [];\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene" && node.next) {\n            edges.push({ from: node.id, to: node.next, label: "next" });\n          }\n          if (node.type === "jump" && node.data?.to) {\n            edges.push({ from: node.id, to: node.data.to, label: "jump" });\n          }\n          if (node.type === "choice") {\n            (node.data?.options ?? []).forEach((option, index) => {\n              if (option?.to) {\n                edges.push({ from: node.id, to: option.to, label: `opt${index + 1}` });\n              }\n            });\n          }\n          if (node.type === "condition") {\n            (node.data?.branches ?? []).forEach((branch, index) => {\n              if (branch?.to) {\n                edges.push({ from: node.id, to: branch.to, label: `br${index + 1}` });\n              }\n            });\n          }\n        }\n        return edges;\n      }\n\n      function connectNodes(fromId, toId) {\n        const source = state.scenario.nodes.find((n) => n.id === fromId);\n        if (!source) {\n          return;\n        }\n        source.data = source.data || {};\n        if (source.type === "scene") {\n          source.next = toId;\n        } else if (source.type === "jump") {\n          source.data.to = toId;\n        } else if (source.type === "choice") {\n          const options = Array.isArray(source.data.options) ? source.data.options : [];\n          const alreadyLinked = options.some((opt) => opt?.to === toId);\n          if (alreadyLinked) {\n            log(`Choice already linked to ${toId}`);\n            return;\n          }\n          if (options.length >= 8) {\n            log("Choice options are limited to 8.", true);\n            return;\n          }\n          const nextIndex = options.length + 1;\n          options.push({\n            id: `opt_${nextIndex}`,\n            label: `선택 ${nextIndex}`,\n            to: toId\n          });\n          source.data.options = options;\n        } else if (source.type === "condition") {\n          const branches = source.data.branches || [];\n          if (branches.length === 0) {\n            source.data.branches = [{ when: "default", to: toId }];\n          } else {\n            branches[0].to = toId;\n          }\n        } else {\n          log(`${source.type} node does not support outgoing links.`, true);\n          return;\n        }\n        persistDraft();\n        if (state.selectedNodeId === source.id) {\n          selectNode(source.id);\n        } else {\n          renderNodes();\n        }\n        el.connectNode.textContent = "Connect (Drag)";\n        log(`Connected ${fromId} -> ${toId}`);\n      }\n\n      function canvasPointFromClient(clientX, clientY) {\n        const rect = el.nodeCanvas.getBoundingClientRect();\n        return {\n          x: clientX - rect.left + el.nodeCanvas.scrollLeft,\n          y: clientY - rect.top + el.nodeCanvas.scrollTop\n        };\n      }\n\n      function findNodeIdFromClient(clientX, clientY) {\n        const element = document.elementFromPoint(clientX, clientY);\n        const nodeEl = element?.closest?.(".node[data-node-id]");\n        if (!nodeEl) {\n          return null;\n        }\n        return nodeEl.getAttribute("data-node-id");\n      }\n\n      function renderNodes() {\n        el.nodeCanvas.innerHTML = "";\n        const content = document.createElement("div");\n        content.className = "canvas-content";\n        el.nodeCanvas.appendChild(content);\n\n        const edgeLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg");\n        edgeLayer.setAttribute("class", "edge-layer");\n        content.appendChild(edgeLayer);\n\n        state.scenario.nodes.forEach((node, index) => ensureNodePosition(node.id, index));\n        const maxX = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.x ?? 0) + 260), 1200);\n        const maxY = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.y ?? 0) + 180), 900);\n        content.style.width = `${maxX}px`;\n        content.style.height = `${maxY}px`;\n\n        for (const edge of getEdgeList()) {\n          const fromPos = state.uiPositions[edge.from];\n          const toPos = state.uiPositions[edge.to];\n          if (!fromPos || !toPos) {\n            continue;\n          }\n          const x1 = fromPos.x + 220;\n          const y1 = fromPos.y + 46;\n          const x2 = toPos.x;\n          const y2 = toPos.y + 46;\n\n          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");\n          line.setAttribute("x1", String(x1));\n          line.setAttribute("y1", String(y1));\n          line.setAttribute("x2", String(x2));\n          line.setAttribute("y2", String(y2));\n          line.setAttribute("class", "edge-line");\n          edgeLayer.appendChild(line);\n\n          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");\n          label.setAttribute("x", String((x1 + x2) / 2));\n          label.setAttribute("y", String((y1 + y2) / 2 - 4));\n          label.setAttribute("class", "edge-label");\n          label.textContent = edge.label;\n          edgeLayer.appendChild(label);\n        }\n\n        if (state.connectDrag) {\n          const fromPos = state.uiPositions[state.connectDrag.fromId];\n          if (fromPos) {\n            const x1 = fromPos.x + 220;\n            const y1 = fromPos.y + 46;\n            const x2 = state.connectDrag.x;\n            const y2 = state.connectDrag.y;\n            const preview = document.createElementNS("http://www.w3.org/2000/svg", "line");\n            preview.setAttribute("x1", String(x1));\n            preview.setAttribute("y1", String(y1));\n            preview.setAttribute("x2", String(x2));\n            preview.setAttribute("y2", String(y2));\n            preview.setAttribute("class", "edge-line");\n            preview.setAttribute("stroke-dasharray", "5 4");\n            edgeLayer.appendChild(preview);\n          }\n        }\n\n        for (const node of state.scenario.nodes) {\n          const div = document.createElement("div");\n          const isSelected = state.selectedNodeId === node.id || state.connectFromId === node.id;\n          const isDragging = state.draggingNodeId === node.id;\n          const isConnectTarget = state.connectHoverNodeId === node.id;\n          div.className = `node ${isSelected ? "selected" : ""} ${isDragging ? "dragging" : ""} ${isConnectTarget ? "connect-target" : ""}`;\n          div.setAttribute("data-node-id", node.id);\n          const pos = state.uiPositions[node.id];\n          div.style.left = `${pos.x}px`;\n          div.style.top = `${pos.y}px`;\n          div.innerHTML = `\n            <div class="node-meta"><span>${node.id}</span><span>${node.type}</span></div>\n            <div class="node-text">${node.data?.text ?? node.data?.prompt ?? "(no text)"}</div>\n            <div class="node-row">\n              <span class="mono">next: ${node.next ?? node.data?.to ?? "-"} / opts:${node.type === "choice" ? (node.data?.options?.length ?? 0) : "-"}</span>\n              <span class="connect-handle" data-role="connect-handle" title="Drag to connect"></span>\n            </div>\n            <div class="mono">bg:${node.data?.background ? "y" : "-"} char:${node.data?.characterImage ? "y" : "-"} bgm:${node.data?.music ? "y" : "-"} spd:${Number.isFinite(Number(node.data?.textSpeed)) ? Math.round(Number(node.data?.textSpeed)) : "-"}</div>\n          `;\n          div.onpointerdown = (event) => {\n            const isHandle = event.target?.closest?.("[data-role=\'connect-handle\']");\n            if (isHandle) {\n              event.preventDefault();\n              event.stopPropagation();\n              state.connectDrag = {\n                fromId: node.id,\n                ...canvasPointFromClient(event.clientX, event.clientY)\n              };\n              state.connectHoverNodeId = null;\n              state.connectFromId = node.id;\n              const onMove = (moveEvent) => {\n                state.connectDrag = {\n                  fromId: node.id,\n                  ...canvasPointFromClient(moveEvent.clientX, moveEvent.clientY)\n                };\n                const hovered = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);\n                state.connectHoverNodeId = hovered && hovered !== node.id ? hovered : null;\n                renderNodes();\n              };\n              const onUp = () => {\n                window.removeEventListener("pointermove", onMove);\n                window.removeEventListener("pointerup", onUp);\n                if (state.connectHoverNodeId && state.connectHoverNodeId !== node.id) {\n                  connectNodes(node.id, state.connectHoverNodeId);\n                }\n                state.connectDrag = null;\n                state.connectHoverNodeId = null;\n                state.connectFromId = null;\n                renderNodes();\n              };\n              window.addEventListener("pointermove", onMove);\n              window.addEventListener("pointerup", onUp);\n              return;\n            }\n\n            event.preventDefault();\n            state.draggingNodeId = node.id;\n            const start = canvasPointFromClient(event.clientX, event.clientY);\n            const origin = { ...state.uiPositions[node.id] };\n            let dragged = false;\n            const onMove = (moveEvent) => {\n              const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);\n              const dx = current.x - start.x;\n              const dy = current.y - start.y;\n              if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {\n                dragged = true;\n              }\n              state.uiPositions[node.id] = {\n                x: Math.max(8, origin.x + dx),\n                y: Math.max(8, origin.y + dy)\n              };\n              renderNodes();\n            };\n            const onUp = () => {\n              window.removeEventListener("pointermove", onMove);\n              window.removeEventListener("pointerup", onUp);\n              state.draggingNodeId = null;\n              if (dragged) {\n                persistDraft();\n              } else {\n                selectNode(node.id);\n              }\n              renderNodes();\n            };\n            window.addEventListener("pointermove", onMove);\n            window.addEventListener("pointerup", onUp);\n          };\n          content.appendChild(div);\n        }\n      }\n\n      function setFieldVisible(element, visible) {\n        element.classList.toggle("hidden", !visible);\n      }\n\n      function updateNodeFormByType(node) {\n        const isScene = node?.type === "scene";\n        const isChoice = node?.type === "choice";\n        const isEnding = node?.type === "ending";\n        el.nodeTextLabel.textContent = isChoice ? "Choice Prompt" : isEnding ? "Ending Title" : "Node Text";\n        setFieldVisible(el.nodeSpeakerField, isScene);\n        setFieldVisible(el.nodeTextSpeedField, isScene);\n        setFieldVisible(el.nodeNextField, isScene);\n        setFieldVisible(el.choiceOptionsField, isChoice);\n      }\n\n      function renderChoiceOptionsEditor(node) {\n        el.choiceOptionsEditor.innerHTML = "";\n        const options = Array.isArray(node?.data?.options) ? node.data.options : [];\n        if (options.length === 0) {\n          const empty = document.createElement("div");\n          empty.className = "mono";\n          empty.textContent = "No options yet. Add one.";\n          el.choiceOptionsEditor.appendChild(empty);\n          return;\n        }\n\n        options.forEach((option, index) => {\n          const row = document.createElement("div");\n          row.className = "choice-option-row";\n          row.dataset.optionId = option?.id || `opt_${index + 1}`;\n          const labelInput = document.createElement("input");\n          labelInput.placeholder = `옵션명 ${index + 1}`;\n          labelInput.value = option?.label || "";\n          labelInput.dataset.field = "label";\n          const toInput = document.createElement("input");\n          toInput.placeholder = "target node id";\n          toInput.value = option?.to || "";\n          toInput.dataset.field = "to";\n          const removeButton = document.createElement("button");\n          removeButton.textContent = "Remove";\n          removeButton.className = "warn";\n          removeButton.onclick = () => {\n            row.remove();\n            if (el.choiceOptionsEditor.children.length === 0) {\n              renderChoiceOptionsEditor({ data: { options: [] } });\n            }\n            applyNodeChanges({ silent: true });\n          };\n          row.appendChild(labelInput);\n          row.appendChild(toInput);\n          row.appendChild(removeButton);\n          el.choiceOptionsEditor.appendChild(row);\n        });\n      }\n\n      function readChoiceOptionsFromEditor() {\n        const rows = [...el.choiceOptionsEditor.querySelectorAll(".choice-option-row")];\n        const options = [];\n        rows.forEach((row, index) => {\n          const label = (row.querySelector("[data-field=\'label\']")?.value || "").trim();\n          const to = (row.querySelector("[data-field=\'to\']")?.value || "").trim();\n          if (!label && !to) {\n            return;\n          }\n          options.push({\n            id: row.dataset.optionId || `opt_${index + 1}`,\n            label: label || `선택 ${index + 1}`,\n            to: to || null\n          });\n        });\n        return options.slice(0, 8);\n      }\n\n      function selectNode(id) {\n        state.selectedNodeId = id;\n        const node = state.scenario.nodes.find((n) => n.id === id);\n        if (!node) return;\n        updateNodeFormByType(node);\n        el.selectedNodeLabel.textContent = `${node.id} (${node.type})`;\n        if (node.type === "choice") {\n          el.nodeText.value = node.data?.prompt ?? "";\n          el.nodeSpeaker.value = "";\n          el.nodeTextSpeed.value = "";\n          el.nodeNext.value = "";\n          renderChoiceOptionsEditor(node);\n        } else {\n          el.nodeText.value = node.type === "ending" ? (node.data?.title ?? "") : (node.data?.text ?? "");\n          el.nodeSpeaker.value = node.data?.speaker ?? "";\n          el.nodeTextSpeed.value = Number.isFinite(Number(node.data?.textSpeed)) ? String(Math.round(Number(node.data?.textSpeed))) : "";\n          el.nodeNext.value = node.next ?? node.data?.to ?? "";\n          renderChoiceOptionsEditor({ data: { options: [] } });\n        }\n        el.nodeBackground.value = node.data?.background ?? "";\n        el.nodeCharacterImage.value = node.data?.characterImage ?? "";\n        el.nodeMusic.value = node.data?.music ?? "";\n        renderNodes();\n      }\n\n      function applyNodeChanges(options = {}) {\n        const { silent = true } = options;\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node) return;\n        node.data = node.data || {};\n        const speaker = (el.nodeSpeaker.value || "").trim();\n        const textSpeedInput = (el.nodeTextSpeed.value || "").trim();\n        const background = (el.nodeBackground.value || "").trim();\n        const characterImage = (el.nodeCharacterImage.value || "").trim();\n        const music = (el.nodeMusic.value || "").trim();\n        if (node.type === "scene") {\n          node.data.text = el.nodeText.value;\n          node.next = el.nodeNext.value || null;\n          if (speaker) {\n            node.data.speaker = speaker;\n          } else {\n            delete node.data.speaker;\n          }\n          if (textSpeedInput === "") {\n            delete node.data.textSpeed;\n          } else {\n            const rawSpeed = Number(textSpeedInput);\n            if (Number.isFinite(rawSpeed)) {\n              node.data.textSpeed = Math.max(0, Math.min(96, Math.round(rawSpeed)));\n            }\n          }\n          delete node.data.prompt;\n          delete node.data.options;\n        } else if (node.type === "jump") {\n          node.data.to = el.nodeNext.value || null;\n          delete node.data.textSpeed;\n        } else if (node.type === "ending") {\n          node.data.title = el.nodeText.value || node.data.title || "Ending";\n          delete node.data.textSpeed;\n          delete node.data.prompt;\n          delete node.data.options;\n        } else if (node.type === "choice") {\n          node.data.prompt = el.nodeText.value || "선택";\n          node.data.options = readChoiceOptionsFromEditor();\n          delete node.next;\n          delete node.data.text;\n          delete node.data.speaker;\n          delete node.data.textSpeed;\n        } else {\n          delete node.data.textSpeed;\n        }\n        if (background) {\n          node.data.background = background;\n        } else {\n          delete node.data.background;\n        }\n        if (characterImage) {\n          node.data.characterImage = characterImage;\n        } else {\n          delete node.data.characterImage;\n        }\n        if (music) {\n          node.data.music = music;\n        } else {\n          delete node.data.music;\n        }\n        renderNodes();\n        persistDraft();\n        if (!silent) {\n          log(`Applied changes to ${node.id}`);\n        }\n      }\n\n      function deleteSelectedNode() {\n        if (!state.selectedNodeId) {\n          log("No selected node to delete.", true);\n          return;\n        }\n        if (state.scenario.nodes.length <= 1) {\n          log("Cannot delete the last node.", true);\n          return;\n        }\n\n        const removeId = state.selectedNodeId;\n        state.scenario.nodes = state.scenario.nodes.filter((n) => n.id !== removeId);\n        delete state.uiPositions[removeId];\n        if (state.connectFromId === removeId) {\n          state.connectFromId = null;\n        }\n\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene" && node.next === removeId) {\n            node.next = null;\n          }\n          if (node.type === "jump" && node.data?.to === removeId) {\n            node.data.to = null;\n          }\n          if (node.type === "choice" && Array.isArray(node.data?.options)) {\n            node.data.options = node.data.options.filter((o) => o.to !== removeId);\n          }\n          if (node.type === "condition" && Array.isArray(node.data?.branches)) {\n            node.data.branches = node.data.branches.filter((b) => b.to !== removeId);\n          }\n        }\n\n        if (state.scenario.entryNodeId === removeId) {\n          state.scenario.entryNodeId = state.scenario.nodes[0]?.id ?? null;\n        }\n        state.selectedNodeId = state.scenario.entryNodeId ?? state.scenario.nodes[0]?.id ?? null;\n        renderNodes();\n        if (state.selectedNodeId) {\n          selectNode(state.selectedNodeId);\n        }\n        persistDraft();\n        log(`Deleted node ${removeId}`);\n      }\n\n      function addNode(type) {\n        const id = `n_${type}_${Math.random().toString(36).slice(2, 6)}`;\n        const node = { id, type, data: {} };\n        if (type === "scene") {\n          node.data.text = "새 장면";\n          node.data.textSpeed = 24;\n          node.next = null;\n        }\n        if (type === "choice") {\n          node.data.prompt = "선택지를 고르세요";\n          node.data.options = [{ id: "opt_1", label: "선택 1", to: "n_end" }];\n        }\n        if (type === "ending") {\n          node.data.endingId = id;\n          node.data.title = "새 엔딩";\n        }\n        state.scenario.nodes.push(node);\n        renderNodes();\n        selectNode(id);\n        persistDraft();\n      }\n\n      el.addChoiceOption.onclick = () => {\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node || node.type !== "choice") {\n          log("Select a choice node first.", true);\n          return;\n        }\n        const currentRows = el.choiceOptionsEditor.querySelectorAll(".choice-option-row").length;\n        if (currentRows >= 8) {\n          log("Choice options are limited to 8.", true);\n          return;\n        }\n        if (el.choiceOptionsEditor.querySelector(".choice-option-row") === null) {\n          el.choiceOptionsEditor.innerHTML = "";\n        }\n        const row = document.createElement("div");\n        row.className = "choice-option-row";\n        row.dataset.optionId = `opt_${currentRows + 1}`;\n        row.innerHTML = `\n          <input data-field="label" placeholder="옵션명 ${currentRows + 1}" />\n          <input data-field="to" placeholder="target node id" />\n          <button class="warn">Remove</button>\n        `;\n        row.querySelector("button").onclick = () => {\n          row.remove();\n          if (el.choiceOptionsEditor.children.length === 0) {\n            renderChoiceOptionsEditor({ data: { options: [] } });\n          }\n          applyNodeChanges({ silent: true });\n        };\n        el.choiceOptionsEditor.appendChild(row);\n        applyNodeChanges({ silent: true });\n      };\n\n      async function createProject() {\n        const res = await fetch("/api/projects", {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            name: el.projectName.value,\n            slug: el.projectSlug.value\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.projectId = body.project?.id || state.projectId;\n          el.projectStatus.textContent = `project: ${body.project?.id ?? "created"} (${body.correlationId})`;\n          persistDraft();\n          log("Project created.");\n        } else {\n          el.projectStatus.textContent = `${body.code}: ${body.message}`;\n          log(`${body.code} ${body.message}`, true);\n        }\n      }\n\n      async function saveScenario(options = {}) {\n        const { silent = false } = options;\n        const res = await fetch(`/api/projects/${state.projectId}/scenario`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            requestedVersion: state.scenarioVersion,\n            currentVersion: state.scenarioVersion,\n            content: state.scenario\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.scenarioVersion = body.nextVersion;\n          persistDraft();\n          if (!silent) {\n            log(`Scenario saved. version=${state.scenarioVersion}`);\n          }\n          return true;\n        } else {\n          if (!silent) {\n            log(`${body.code} ${body.message}`, true);\n          }\n          return false;\n        }\n      }\n\n      async function validateScenario() {\n        const res = await fetch(`/api/projects/${state.projectId}/validate`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ scenario: state.scenario })\n        });\n        const body = await res.json();\n        const issues = body.issues || body.details?.errors || [];\n        el.issues.innerHTML = "";\n        el.issueCount.textContent = String(issues.length);\n        issues.forEach((issue) => {\n          const div = document.createElement("div");\n          div.className = "issue";\n          div.innerHTML = `<strong>${issue.code}</strong> ${issue.message}`;\n          el.issues.appendChild(div);\n        });\n        if (res.ok) {\n          log("Validation passed.");\n        } else {\n          log(`${body.code} (${issues.length} issues)`, true);\n        }\n      }\n\n      async function buildSeo() {\n        const res = await fetch(`/api/projects/${state.projectId}/build`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ jobType: "seo" })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          log(`Build queued (${body.jobType})`);\n        } else {\n          log(`${body.code}: ${body.message}`, true);\n        }\n      }\n\n      async function openPlayer() {\n        const projectRef = state.projectId || el.projectSlug.value?.trim();\n        if (!projectRef) {\n          log("No project id/slug available for player test.", true);\n          return;\n        }\n        const saved = await saveScenario({ silent: true });\n        if (!saved) {\n          log("Play Test aborted: scenario save failed.", true);\n          return;\n        }\n        const target = `${playerBaseUrl}/play/${encodeURIComponent(projectRef)}`;\n        window.open(target, "_blank", "noopener,noreferrer");\n        log(`Opened player test: ${projectRef}`);\n      }\n\n      function toggleConnectMode() {\n        log("Drag the green handle on a node and drop it on target node to connect.");\n      }\n\n      el.createProjectBtn.onclick = createProject;\n      el.addScene.onclick = () => addNode("scene");\n      el.addChoice.onclick = () => addNode("choice");\n      el.addEnding.onclick = () => addNode("ending");\n      el.saveScenario.onclick = saveScenario;\n      el.validateScenario.onclick = validateScenario;\n      el.connectNode.onclick = toggleConnectMode;\n      el.buildSeo.onclick = buildSeo;\n      el.openPlayer.onclick = openPlayer;\n      el.deleteNode.onclick = deleteSelectedNode;\n      el.projectName.addEventListener("change", persistDraft);\n      el.projectSlug.addEventListener("change", persistDraft);\n      [el.nodeText, el.nodeSpeaker, el.nodeTextSpeed, el.nodeNext, el.nodeBackground, el.nodeCharacterImage, el.nodeMusic].forEach((input) => {\n        input.addEventListener("input", () => applyNodeChanges({ silent: true }));\n      });\n      el.choiceOptionsEditor.addEventListener("input", () => applyNodeChanges({ silent: true }));\n\n      restoreDraft();\n      renderNodes();\n      selectNode(state.scenario.entryNodeId || "n_start");\n    </script> </body> </html>'], ['<html lang="ko" data-astro-cid-j7pv25f6> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>VN Studio</title>', '</head> <body data-astro-cid-j7pv25f6> <main class="layout" data-astro-cid-j7pv25f6> <section class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h1 data-astro-cid-j7pv25f6>PIXEL VN STUDIO</h1> <h3 data-astro-cid-j7pv25f6>Project + Scenario Authoring</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label data-astro-cid-j7pv25f6>Project Name <input id="projectName" value="My VN" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Project Slug <input id="projectSlug" value="my-vn" data-astro-cid-j7pv25f6></label> <button class="primary" id="createProjectBtn" data-astro-cid-j7pv25f6>Create Project</button> <div id="projectStatus" class="mono" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="group stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTOR CONTEXT</h2> <label data-astro-cid-j7pv25f6>Role\n<select id="role" data-astro-cid-j7pv25f6> <option value="owner" data-astro-cid-j7pv25f6>owner</option> <option value="editor" selected data-astro-cid-j7pv25f6>editor</option> <option value="viewer" data-astro-cid-j7pv25f6>viewer</option> </select> </label> <label data-astro-cid-j7pv25f6>Plan\n<select id="plan" data-astro-cid-j7pv25f6> <option value="free" selected data-astro-cid-j7pv25f6>free</option> <option value="pro" data-astro-cid-j7pv25f6>pro</option> </select> </label> <label data-astro-cid-j7pv25f6>User ID <input id="userId" value="00000000-0000-0000-0000-000000000010" data-astro-cid-j7pv25f6></label> <label data-astro-cid-j7pv25f6>Org ID <input id="orgId" value="00000000-0000-0000-0000-000000000020" data-astro-cid-j7pv25f6></label> </div> </section> <section class="panel editor-panel" data-astro-cid-j7pv25f6> <div class="toolbar" data-astro-cid-j7pv25f6> <button id="addScene" data-astro-cid-j7pv25f6>+ Scene</button> <button id="addChoice" data-astro-cid-j7pv25f6>+ Choice</button> <button id="addEnding" data-astro-cid-j7pv25f6>+ Ending</button> <button id="saveScenario" class="primary" data-astro-cid-j7pv25f6>Save Scenario</button> <button id="validateScenario" data-astro-cid-j7pv25f6>Validate</button> <button id="connectNode" data-astro-cid-j7pv25f6>Connect (Drag)</button> <button id="buildSeo" class="warn" data-astro-cid-j7pv25f6>Build SEO</button> <button id="openPlayer" data-astro-cid-j7pv25f6>Play Test</button> </div> <div class="canvas" id="nodeCanvas" data-astro-cid-j7pv25f6></div> </section> <aside class="panel" data-astro-cid-j7pv25f6> <div class="panel-sticky" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>NODE PROPERTIES</h2> <h3 id="selectedNodeLabel" data-astro-cid-j7pv25f6>No node selected</h3> </div> <div class="group stack" data-astro-cid-j7pv25f6> <label id="nodeTextField" data-astro-cid-j7pv25f6><span id="nodeTextLabel" data-astro-cid-j7pv25f6>Node Text</span> <textarea id="nodeText" rows="5" placeholder="scene text" data-astro-cid-j7pv25f6></textarea> </label> <label id="nodeSpeakerField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Character Name</span> <input id="nodeSpeaker" placeholder="Narrator" data-astro-cid-j7pv25f6> </label> <label id="nodeTextSpeedField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Text Speed (ms, 0 = instant)</span> <input id="nodeTextSpeed" type="number" min="0" max="96" step="1" placeholder="24" data-astro-cid-j7pv25f6> </label> <label id="nodeNextField" data-astro-cid-j7pv25f6><span data-astro-cid-j7pv25f6>Next Node ID</span> <input id="nodeNext" placeholder="n_end" data-astro-cid-j7pv25f6> </label> <div id="choiceOptionsField" class="hidden" data-astro-cid-j7pv25f6> <span data-astro-cid-j7pv25f6>Choice Options</span> <div id="choiceOptionsEditor" class="choice-options" data-astro-cid-j7pv25f6></div> <button id="addChoiceOption" data-astro-cid-j7pv25f6>+ Option</button> </div> <label data-astro-cid-j7pv25f6>Background URL\n<input id="nodeBackground" placeholder="/assets/bg/school.jpg" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>Character Image URL\n<input id="nodeCharacterImage" placeholder="/assets/char/hero.png" data-astro-cid-j7pv25f6> </label> <label data-astro-cid-j7pv25f6>BGM URL\n<input id="nodeMusic" placeholder="/assets/bgm/theme.mp3" data-astro-cid-j7pv25f6> </label> <button id="deleteNode" class="warn" data-astro-cid-j7pv25f6>Delete Node</button> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>VALIDATION ISSUES <span id="issueCount" class="badge" data-astro-cid-j7pv25f6>0</span></h2> <div id="issues" class="issues" data-astro-cid-j7pv25f6></div> </div> <hr class="divider" data-astro-cid-j7pv25f6> <div class="stack" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>ACTIVITY</h2> <div id="activity" class="mono" data-astro-cid-j7pv25f6></div> </div> </aside> </main> <script type="module">', '\n      const state = {\n        projectId: "p1",\n        scenarioVersion: 1,\n        selectedNodeId: null,\n        connectFromId: null,\n        draggingNodeId: null,\n        connectDrag: null,\n        connectHoverNodeId: null,\n        scenario: structuredClone(defaultScenario),\n        uiPositions: {}\n      };\n\n      const el = {\n        projectName: document.getElementById("projectName"),\n        projectSlug: document.getElementById("projectSlug"),\n        createProjectBtn: document.getElementById("createProjectBtn"),\n        projectStatus: document.getElementById("projectStatus"),\n        role: document.getElementById("role"),\n        plan: document.getElementById("plan"),\n        userId: document.getElementById("userId"),\n        orgId: document.getElementById("orgId"),\n        nodeCanvas: document.getElementById("nodeCanvas"),\n        selectedNodeLabel: document.getElementById("selectedNodeLabel"),\n        nodeTextField: document.getElementById("nodeTextField"),\n        nodeTextLabel: document.getElementById("nodeTextLabel"),\n        nodeText: document.getElementById("nodeText"),\n        nodeSpeakerField: document.getElementById("nodeSpeakerField"),\n        nodeSpeaker: document.getElementById("nodeSpeaker"),\n        nodeTextSpeedField: document.getElementById("nodeTextSpeedField"),\n        nodeTextSpeed: document.getElementById("nodeTextSpeed"),\n        nodeNextField: document.getElementById("nodeNextField"),\n        nodeNext: document.getElementById("nodeNext"),\n        choiceOptionsField: document.getElementById("choiceOptionsField"),\n        choiceOptionsEditor: document.getElementById("choiceOptionsEditor"),\n        addChoiceOption: document.getElementById("addChoiceOption"),\n        nodeBackground: document.getElementById("nodeBackground"),\n        nodeCharacterImage: document.getElementById("nodeCharacterImage"),\n        nodeMusic: document.getElementById("nodeMusic"),\n        deleteNode: document.getElementById("deleteNode"),\n        addScene: document.getElementById("addScene"),\n        addChoice: document.getElementById("addChoice"),\n        addEnding: document.getElementById("addEnding"),\n        saveScenario: document.getElementById("saveScenario"),\n        validateScenario: document.getElementById("validateScenario"),\n        connectNode: document.getElementById("connectNode"),\n        buildSeo: document.getElementById("buildSeo"),\n        openPlayer: document.getElementById("openPlayer"),\n        issues: document.getElementById("issues"),\n        issueCount: document.getElementById("issueCount"),\n        activity: document.getElementById("activity")\n      };\n\n      function headers() {\n        return {\n          "content-type": "application/json",\n          "x-user-role": el.role.value,\n          "x-plan-tier": el.plan.value,\n          "x-user-id": el.userId.value,\n          "x-org-id": el.orgId.value\n        };\n      }\n\n      function draftKey() {\n        const ref = state.projectId || el.projectSlug.value || "default";\n        return \\`vn.studio.draft.\\${ref}\\`;\n      }\n\n      function persistDraft() {\n        const snapshot = {\n          projectId: state.projectId,\n          scenarioVersion: state.scenarioVersion,\n          scenario: state.scenario,\n          uiPositions: state.uiPositions,\n          projectName: el.projectName.value,\n          projectSlug: el.projectSlug.value\n        };\n        localStorage.setItem(draftKey(), JSON.stringify(snapshot));\n      }\n\n      function restoreDraft() {\n        const currentRef = state.projectId || el.projectSlug.value;\n        if (!currentRef) {\n          return;\n        }\n        const raw = localStorage.getItem(\\`vn.studio.draft.\\${currentRef}\\`);\n        if (!raw) {\n          return;\n        }\n        try {\n          const parsed = JSON.parse(raw);\n          if (parsed.projectId) state.projectId = parsed.projectId;\n          if (Number.isInteger(parsed.scenarioVersion)) state.scenarioVersion = parsed.scenarioVersion;\n          if (parsed.projectName) el.projectName.value = parsed.projectName;\n          if (parsed.projectSlug) el.projectSlug.value = parsed.projectSlug;\n          if (parsed.scenario?.entryNodeId && Array.isArray(parsed.scenario?.nodes)) {\n            state.scenario = parsed.scenario;\n          }\n          if (parsed.uiPositions && typeof parsed.uiPositions === "object") {\n            state.uiPositions = parsed.uiPositions;\n          }\n          log("Draft restored from local storage.");\n        } catch (error) {\n          log(\\`Draft restore failed: \\${error.message}\\`, true);\n        }\n      }\n\n      function log(message, error = false) {\n        const line = document.createElement("div");\n        line.textContent = \\`[\\${new Date().toLocaleTimeString()}] \\${message}\\`;\n        line.className = error ? "error" : "ok";\n        el.activity.prepend(line);\n      }\n\n      function ensureNodePosition(nodeId, fallbackIndex = 0) {\n        if (state.uiPositions[nodeId]) {\n          return state.uiPositions[nodeId];\n        }\n        const position = {\n          x: 24 + (fallbackIndex % 4) * 250,\n          y: 24 + Math.floor(fallbackIndex / 4) * 170\n        };\n        state.uiPositions[nodeId] = position;\n        return position;\n      }\n\n      function getEdgeList() {\n        const edges = [];\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene" && node.next) {\n            edges.push({ from: node.id, to: node.next, label: "next" });\n          }\n          if (node.type === "jump" && node.data?.to) {\n            edges.push({ from: node.id, to: node.data.to, label: "jump" });\n          }\n          if (node.type === "choice") {\n            (node.data?.options ?? []).forEach((option, index) => {\n              if (option?.to) {\n                edges.push({ from: node.id, to: option.to, label: \\`opt\\${index + 1}\\` });\n              }\n            });\n          }\n          if (node.type === "condition") {\n            (node.data?.branches ?? []).forEach((branch, index) => {\n              if (branch?.to) {\n                edges.push({ from: node.id, to: branch.to, label: \\`br\\${index + 1}\\` });\n              }\n            });\n          }\n        }\n        return edges;\n      }\n\n      function connectNodes(fromId, toId) {\n        const source = state.scenario.nodes.find((n) => n.id === fromId);\n        if (!source) {\n          return;\n        }\n        source.data = source.data || {};\n        if (source.type === "scene") {\n          source.next = toId;\n        } else if (source.type === "jump") {\n          source.data.to = toId;\n        } else if (source.type === "choice") {\n          const options = Array.isArray(source.data.options) ? source.data.options : [];\n          const alreadyLinked = options.some((opt) => opt?.to === toId);\n          if (alreadyLinked) {\n            log(\\`Choice already linked to \\${toId}\\`);\n            return;\n          }\n          if (options.length >= 8) {\n            log("Choice options are limited to 8.", true);\n            return;\n          }\n          const nextIndex = options.length + 1;\n          options.push({\n            id: \\`opt_\\${nextIndex}\\`,\n            label: \\`선택 \\${nextIndex}\\`,\n            to: toId\n          });\n          source.data.options = options;\n        } else if (source.type === "condition") {\n          const branches = source.data.branches || [];\n          if (branches.length === 0) {\n            source.data.branches = [{ when: "default", to: toId }];\n          } else {\n            branches[0].to = toId;\n          }\n        } else {\n          log(\\`\\${source.type} node does not support outgoing links.\\`, true);\n          return;\n        }\n        persistDraft();\n        if (state.selectedNodeId === source.id) {\n          selectNode(source.id);\n        } else {\n          renderNodes();\n        }\n        el.connectNode.textContent = "Connect (Drag)";\n        log(\\`Connected \\${fromId} -> \\${toId}\\`);\n      }\n\n      function canvasPointFromClient(clientX, clientY) {\n        const rect = el.nodeCanvas.getBoundingClientRect();\n        return {\n          x: clientX - rect.left + el.nodeCanvas.scrollLeft,\n          y: clientY - rect.top + el.nodeCanvas.scrollTop\n        };\n      }\n\n      function findNodeIdFromClient(clientX, clientY) {\n        const element = document.elementFromPoint(clientX, clientY);\n        const nodeEl = element?.closest?.(".node[data-node-id]");\n        if (!nodeEl) {\n          return null;\n        }\n        return nodeEl.getAttribute("data-node-id");\n      }\n\n      function renderNodes() {\n        el.nodeCanvas.innerHTML = "";\n        const content = document.createElement("div");\n        content.className = "canvas-content";\n        el.nodeCanvas.appendChild(content);\n\n        const edgeLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg");\n        edgeLayer.setAttribute("class", "edge-layer");\n        content.appendChild(edgeLayer);\n\n        state.scenario.nodes.forEach((node, index) => ensureNodePosition(node.id, index));\n        const maxX = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.x ?? 0) + 260), 1200);\n        const maxY = state.scenario.nodes.reduce((m, n) => Math.max(m, (state.uiPositions[n.id]?.y ?? 0) + 180), 900);\n        content.style.width = \\`\\${maxX}px\\`;\n        content.style.height = \\`\\${maxY}px\\`;\n\n        for (const edge of getEdgeList()) {\n          const fromPos = state.uiPositions[edge.from];\n          const toPos = state.uiPositions[edge.to];\n          if (!fromPos || !toPos) {\n            continue;\n          }\n          const x1 = fromPos.x + 220;\n          const y1 = fromPos.y + 46;\n          const x2 = toPos.x;\n          const y2 = toPos.y + 46;\n\n          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");\n          line.setAttribute("x1", String(x1));\n          line.setAttribute("y1", String(y1));\n          line.setAttribute("x2", String(x2));\n          line.setAttribute("y2", String(y2));\n          line.setAttribute("class", "edge-line");\n          edgeLayer.appendChild(line);\n\n          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");\n          label.setAttribute("x", String((x1 + x2) / 2));\n          label.setAttribute("y", String((y1 + y2) / 2 - 4));\n          label.setAttribute("class", "edge-label");\n          label.textContent = edge.label;\n          edgeLayer.appendChild(label);\n        }\n\n        if (state.connectDrag) {\n          const fromPos = state.uiPositions[state.connectDrag.fromId];\n          if (fromPos) {\n            const x1 = fromPos.x + 220;\n            const y1 = fromPos.y + 46;\n            const x2 = state.connectDrag.x;\n            const y2 = state.connectDrag.y;\n            const preview = document.createElementNS("http://www.w3.org/2000/svg", "line");\n            preview.setAttribute("x1", String(x1));\n            preview.setAttribute("y1", String(y1));\n            preview.setAttribute("x2", String(x2));\n            preview.setAttribute("y2", String(y2));\n            preview.setAttribute("class", "edge-line");\n            preview.setAttribute("stroke-dasharray", "5 4");\n            edgeLayer.appendChild(preview);\n          }\n        }\n\n        for (const node of state.scenario.nodes) {\n          const div = document.createElement("div");\n          const isSelected = state.selectedNodeId === node.id || state.connectFromId === node.id;\n          const isDragging = state.draggingNodeId === node.id;\n          const isConnectTarget = state.connectHoverNodeId === node.id;\n          div.className = \\`node \\${isSelected ? "selected" : ""} \\${isDragging ? "dragging" : ""} \\${isConnectTarget ? "connect-target" : ""}\\`;\n          div.setAttribute("data-node-id", node.id);\n          const pos = state.uiPositions[node.id];\n          div.style.left = \\`\\${pos.x}px\\`;\n          div.style.top = \\`\\${pos.y}px\\`;\n          div.innerHTML = \\`\n            <div class="node-meta"><span>\\${node.id}</span><span>\\${node.type}</span></div>\n            <div class="node-text">\\${node.data?.text ?? node.data?.prompt ?? "(no text)"}</div>\n            <div class="node-row">\n              <span class="mono">next: \\${node.next ?? node.data?.to ?? "-"} / opts:\\${node.type === "choice" ? (node.data?.options?.length ?? 0) : "-"}</span>\n              <span class="connect-handle" data-role="connect-handle" title="Drag to connect"></span>\n            </div>\n            <div class="mono">bg:\\${node.data?.background ? "y" : "-"} char:\\${node.data?.characterImage ? "y" : "-"} bgm:\\${node.data?.music ? "y" : "-"} spd:\\${Number.isFinite(Number(node.data?.textSpeed)) ? Math.round(Number(node.data?.textSpeed)) : "-"}</div>\n          \\`;\n          div.onpointerdown = (event) => {\n            const isHandle = event.target?.closest?.("[data-role=\'connect-handle\']");\n            if (isHandle) {\n              event.preventDefault();\n              event.stopPropagation();\n              state.connectDrag = {\n                fromId: node.id,\n                ...canvasPointFromClient(event.clientX, event.clientY)\n              };\n              state.connectHoverNodeId = null;\n              state.connectFromId = node.id;\n              const onMove = (moveEvent) => {\n                state.connectDrag = {\n                  fromId: node.id,\n                  ...canvasPointFromClient(moveEvent.clientX, moveEvent.clientY)\n                };\n                const hovered = findNodeIdFromClient(moveEvent.clientX, moveEvent.clientY);\n                state.connectHoverNodeId = hovered && hovered !== node.id ? hovered : null;\n                renderNodes();\n              };\n              const onUp = () => {\n                window.removeEventListener("pointermove", onMove);\n                window.removeEventListener("pointerup", onUp);\n                if (state.connectHoverNodeId && state.connectHoverNodeId !== node.id) {\n                  connectNodes(node.id, state.connectHoverNodeId);\n                }\n                state.connectDrag = null;\n                state.connectHoverNodeId = null;\n                state.connectFromId = null;\n                renderNodes();\n              };\n              window.addEventListener("pointermove", onMove);\n              window.addEventListener("pointerup", onUp);\n              return;\n            }\n\n            event.preventDefault();\n            state.draggingNodeId = node.id;\n            const start = canvasPointFromClient(event.clientX, event.clientY);\n            const origin = { ...state.uiPositions[node.id] };\n            let dragged = false;\n            const onMove = (moveEvent) => {\n              const current = canvasPointFromClient(moveEvent.clientX, moveEvent.clientY);\n              const dx = current.x - start.x;\n              const dy = current.y - start.y;\n              if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {\n                dragged = true;\n              }\n              state.uiPositions[node.id] = {\n                x: Math.max(8, origin.x + dx),\n                y: Math.max(8, origin.y + dy)\n              };\n              renderNodes();\n            };\n            const onUp = () => {\n              window.removeEventListener("pointermove", onMove);\n              window.removeEventListener("pointerup", onUp);\n              state.draggingNodeId = null;\n              if (dragged) {\n                persistDraft();\n              } else {\n                selectNode(node.id);\n              }\n              renderNodes();\n            };\n            window.addEventListener("pointermove", onMove);\n            window.addEventListener("pointerup", onUp);\n          };\n          content.appendChild(div);\n        }\n      }\n\n      function setFieldVisible(element, visible) {\n        element.classList.toggle("hidden", !visible);\n      }\n\n      function updateNodeFormByType(node) {\n        const isScene = node?.type === "scene";\n        const isChoice = node?.type === "choice";\n        const isEnding = node?.type === "ending";\n        el.nodeTextLabel.textContent = isChoice ? "Choice Prompt" : isEnding ? "Ending Title" : "Node Text";\n        setFieldVisible(el.nodeSpeakerField, isScene);\n        setFieldVisible(el.nodeTextSpeedField, isScene);\n        setFieldVisible(el.nodeNextField, isScene);\n        setFieldVisible(el.choiceOptionsField, isChoice);\n      }\n\n      function renderChoiceOptionsEditor(node) {\n        el.choiceOptionsEditor.innerHTML = "";\n        const options = Array.isArray(node?.data?.options) ? node.data.options : [];\n        if (options.length === 0) {\n          const empty = document.createElement("div");\n          empty.className = "mono";\n          empty.textContent = "No options yet. Add one.";\n          el.choiceOptionsEditor.appendChild(empty);\n          return;\n        }\n\n        options.forEach((option, index) => {\n          const row = document.createElement("div");\n          row.className = "choice-option-row";\n          row.dataset.optionId = option?.id || \\`opt_\\${index + 1}\\`;\n          const labelInput = document.createElement("input");\n          labelInput.placeholder = \\`옵션명 \\${index + 1}\\`;\n          labelInput.value = option?.label || "";\n          labelInput.dataset.field = "label";\n          const toInput = document.createElement("input");\n          toInput.placeholder = "target node id";\n          toInput.value = option?.to || "";\n          toInput.dataset.field = "to";\n          const removeButton = document.createElement("button");\n          removeButton.textContent = "Remove";\n          removeButton.className = "warn";\n          removeButton.onclick = () => {\n            row.remove();\n            if (el.choiceOptionsEditor.children.length === 0) {\n              renderChoiceOptionsEditor({ data: { options: [] } });\n            }\n            applyNodeChanges({ silent: true });\n          };\n          row.appendChild(labelInput);\n          row.appendChild(toInput);\n          row.appendChild(removeButton);\n          el.choiceOptionsEditor.appendChild(row);\n        });\n      }\n\n      function readChoiceOptionsFromEditor() {\n        const rows = [...el.choiceOptionsEditor.querySelectorAll(".choice-option-row")];\n        const options = [];\n        rows.forEach((row, index) => {\n          const label = (row.querySelector("[data-field=\'label\']")?.value || "").trim();\n          const to = (row.querySelector("[data-field=\'to\']")?.value || "").trim();\n          if (!label && !to) {\n            return;\n          }\n          options.push({\n            id: row.dataset.optionId || \\`opt_\\${index + 1}\\`,\n            label: label || \\`선택 \\${index + 1}\\`,\n            to: to || null\n          });\n        });\n        return options.slice(0, 8);\n      }\n\n      function selectNode(id) {\n        state.selectedNodeId = id;\n        const node = state.scenario.nodes.find((n) => n.id === id);\n        if (!node) return;\n        updateNodeFormByType(node);\n        el.selectedNodeLabel.textContent = \\`\\${node.id} (\\${node.type})\\`;\n        if (node.type === "choice") {\n          el.nodeText.value = node.data?.prompt ?? "";\n          el.nodeSpeaker.value = "";\n          el.nodeTextSpeed.value = "";\n          el.nodeNext.value = "";\n          renderChoiceOptionsEditor(node);\n        } else {\n          el.nodeText.value = node.type === "ending" ? (node.data?.title ?? "") : (node.data?.text ?? "");\n          el.nodeSpeaker.value = node.data?.speaker ?? "";\n          el.nodeTextSpeed.value = Number.isFinite(Number(node.data?.textSpeed)) ? String(Math.round(Number(node.data?.textSpeed))) : "";\n          el.nodeNext.value = node.next ?? node.data?.to ?? "";\n          renderChoiceOptionsEditor({ data: { options: [] } });\n        }\n        el.nodeBackground.value = node.data?.background ?? "";\n        el.nodeCharacterImage.value = node.data?.characterImage ?? "";\n        el.nodeMusic.value = node.data?.music ?? "";\n        renderNodes();\n      }\n\n      function applyNodeChanges(options = {}) {\n        const { silent = true } = options;\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node) return;\n        node.data = node.data || {};\n        const speaker = (el.nodeSpeaker.value || "").trim();\n        const textSpeedInput = (el.nodeTextSpeed.value || "").trim();\n        const background = (el.nodeBackground.value || "").trim();\n        const characterImage = (el.nodeCharacterImage.value || "").trim();\n        const music = (el.nodeMusic.value || "").trim();\n        if (node.type === "scene") {\n          node.data.text = el.nodeText.value;\n          node.next = el.nodeNext.value || null;\n          if (speaker) {\n            node.data.speaker = speaker;\n          } else {\n            delete node.data.speaker;\n          }\n          if (textSpeedInput === "") {\n            delete node.data.textSpeed;\n          } else {\n            const rawSpeed = Number(textSpeedInput);\n            if (Number.isFinite(rawSpeed)) {\n              node.data.textSpeed = Math.max(0, Math.min(96, Math.round(rawSpeed)));\n            }\n          }\n          delete node.data.prompt;\n          delete node.data.options;\n        } else if (node.type === "jump") {\n          node.data.to = el.nodeNext.value || null;\n          delete node.data.textSpeed;\n        } else if (node.type === "ending") {\n          node.data.title = el.nodeText.value || node.data.title || "Ending";\n          delete node.data.textSpeed;\n          delete node.data.prompt;\n          delete node.data.options;\n        } else if (node.type === "choice") {\n          node.data.prompt = el.nodeText.value || "선택";\n          node.data.options = readChoiceOptionsFromEditor();\n          delete node.next;\n          delete node.data.text;\n          delete node.data.speaker;\n          delete node.data.textSpeed;\n        } else {\n          delete node.data.textSpeed;\n        }\n        if (background) {\n          node.data.background = background;\n        } else {\n          delete node.data.background;\n        }\n        if (characterImage) {\n          node.data.characterImage = characterImage;\n        } else {\n          delete node.data.characterImage;\n        }\n        if (music) {\n          node.data.music = music;\n        } else {\n          delete node.data.music;\n        }\n        renderNodes();\n        persistDraft();\n        if (!silent) {\n          log(\\`Applied changes to \\${node.id}\\`);\n        }\n      }\n\n      function deleteSelectedNode() {\n        if (!state.selectedNodeId) {\n          log("No selected node to delete.", true);\n          return;\n        }\n        if (state.scenario.nodes.length <= 1) {\n          log("Cannot delete the last node.", true);\n          return;\n        }\n\n        const removeId = state.selectedNodeId;\n        state.scenario.nodes = state.scenario.nodes.filter((n) => n.id !== removeId);\n        delete state.uiPositions[removeId];\n        if (state.connectFromId === removeId) {\n          state.connectFromId = null;\n        }\n\n        for (const node of state.scenario.nodes) {\n          if (node.type === "scene" && node.next === removeId) {\n            node.next = null;\n          }\n          if (node.type === "jump" && node.data?.to === removeId) {\n            node.data.to = null;\n          }\n          if (node.type === "choice" && Array.isArray(node.data?.options)) {\n            node.data.options = node.data.options.filter((o) => o.to !== removeId);\n          }\n          if (node.type === "condition" && Array.isArray(node.data?.branches)) {\n            node.data.branches = node.data.branches.filter((b) => b.to !== removeId);\n          }\n        }\n\n        if (state.scenario.entryNodeId === removeId) {\n          state.scenario.entryNodeId = state.scenario.nodes[0]?.id ?? null;\n        }\n        state.selectedNodeId = state.scenario.entryNodeId ?? state.scenario.nodes[0]?.id ?? null;\n        renderNodes();\n        if (state.selectedNodeId) {\n          selectNode(state.selectedNodeId);\n        }\n        persistDraft();\n        log(\\`Deleted node \\${removeId}\\`);\n      }\n\n      function addNode(type) {\n        const id = \\`n_\\${type}_\\${Math.random().toString(36).slice(2, 6)}\\`;\n        const node = { id, type, data: {} };\n        if (type === "scene") {\n          node.data.text = "새 장면";\n          node.data.textSpeed = 24;\n          node.next = null;\n        }\n        if (type === "choice") {\n          node.data.prompt = "선택지를 고르세요";\n          node.data.options = [{ id: "opt_1", label: "선택 1", to: "n_end" }];\n        }\n        if (type === "ending") {\n          node.data.endingId = id;\n          node.data.title = "새 엔딩";\n        }\n        state.scenario.nodes.push(node);\n        renderNodes();\n        selectNode(id);\n        persistDraft();\n      }\n\n      el.addChoiceOption.onclick = () => {\n        const node = state.scenario.nodes.find((n) => n.id === state.selectedNodeId);\n        if (!node || node.type !== "choice") {\n          log("Select a choice node first.", true);\n          return;\n        }\n        const currentRows = el.choiceOptionsEditor.querySelectorAll(".choice-option-row").length;\n        if (currentRows >= 8) {\n          log("Choice options are limited to 8.", true);\n          return;\n        }\n        if (el.choiceOptionsEditor.querySelector(".choice-option-row") === null) {\n          el.choiceOptionsEditor.innerHTML = "";\n        }\n        const row = document.createElement("div");\n        row.className = "choice-option-row";\n        row.dataset.optionId = \\`opt_\\${currentRows + 1}\\`;\n        row.innerHTML = \\`\n          <input data-field="label" placeholder="옵션명 \\${currentRows + 1}" />\n          <input data-field="to" placeholder="target node id" />\n          <button class="warn">Remove</button>\n        \\`;\n        row.querySelector("button").onclick = () => {\n          row.remove();\n          if (el.choiceOptionsEditor.children.length === 0) {\n            renderChoiceOptionsEditor({ data: { options: [] } });\n          }\n          applyNodeChanges({ silent: true });\n        };\n        el.choiceOptionsEditor.appendChild(row);\n        applyNodeChanges({ silent: true });\n      };\n\n      async function createProject() {\n        const res = await fetch("/api/projects", {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            name: el.projectName.value,\n            slug: el.projectSlug.value\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.projectId = body.project?.id || state.projectId;\n          el.projectStatus.textContent = \\`project: \\${body.project?.id ?? "created"} (\\${body.correlationId})\\`;\n          persistDraft();\n          log("Project created.");\n        } else {\n          el.projectStatus.textContent = \\`\\${body.code}: \\${body.message}\\`;\n          log(\\`\\${body.code} \\${body.message}\\`, true);\n        }\n      }\n\n      async function saveScenario(options = {}) {\n        const { silent = false } = options;\n        const res = await fetch(\\`/api/projects/\\${state.projectId}/scenario\\`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({\n            requestedVersion: state.scenarioVersion,\n            currentVersion: state.scenarioVersion,\n            content: state.scenario\n          })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          state.scenarioVersion = body.nextVersion;\n          persistDraft();\n          if (!silent) {\n            log(\\`Scenario saved. version=\\${state.scenarioVersion}\\`);\n          }\n          return true;\n        } else {\n          if (!silent) {\n            log(\\`\\${body.code} \\${body.message}\\`, true);\n          }\n          return false;\n        }\n      }\n\n      async function validateScenario() {\n        const res = await fetch(\\`/api/projects/\\${state.projectId}/validate\\`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ scenario: state.scenario })\n        });\n        const body = await res.json();\n        const issues = body.issues || body.details?.errors || [];\n        el.issues.innerHTML = "";\n        el.issueCount.textContent = String(issues.length);\n        issues.forEach((issue) => {\n          const div = document.createElement("div");\n          div.className = "issue";\n          div.innerHTML = \\`<strong>\\${issue.code}</strong> \\${issue.message}\\`;\n          el.issues.appendChild(div);\n        });\n        if (res.ok) {\n          log("Validation passed.");\n        } else {\n          log(\\`\\${body.code} (\\${issues.length} issues)\\`, true);\n        }\n      }\n\n      async function buildSeo() {\n        const res = await fetch(\\`/api/projects/\\${state.projectId}/build\\`, {\n          method: "POST",\n          headers: headers(),\n          body: JSON.stringify({ jobType: "seo" })\n        });\n        const body = await res.json();\n        if (res.ok) {\n          log(\\`Build queued (\\${body.jobType})\\`);\n        } else {\n          log(\\`\\${body.code}: \\${body.message}\\`, true);\n        }\n      }\n\n      async function openPlayer() {\n        const projectRef = state.projectId || el.projectSlug.value?.trim();\n        if (!projectRef) {\n          log("No project id/slug available for player test.", true);\n          return;\n        }\n        const saved = await saveScenario({ silent: true });\n        if (!saved) {\n          log("Play Test aborted: scenario save failed.", true);\n          return;\n        }\n        const target = \\`\\${playerBaseUrl}/play/\\${encodeURIComponent(projectRef)}\\`;\n        window.open(target, "_blank", "noopener,noreferrer");\n        log(\\`Opened player test: \\${projectRef}\\`);\n      }\n\n      function toggleConnectMode() {\n        log("Drag the green handle on a node and drop it on target node to connect.");\n      }\n\n      el.createProjectBtn.onclick = createProject;\n      el.addScene.onclick = () => addNode("scene");\n      el.addChoice.onclick = () => addNode("choice");\n      el.addEnding.onclick = () => addNode("ending");\n      el.saveScenario.onclick = saveScenario;\n      el.validateScenario.onclick = validateScenario;\n      el.connectNode.onclick = toggleConnectMode;\n      el.buildSeo.onclick = buildSeo;\n      el.openPlayer.onclick = openPlayer;\n      el.deleteNode.onclick = deleteSelectedNode;\n      el.projectName.addEventListener("change", persistDraft);\n      el.projectSlug.addEventListener("change", persistDraft);\n      [el.nodeText, el.nodeSpeaker, el.nodeTextSpeed, el.nodeNext, el.nodeBackground, el.nodeCharacterImage, el.nodeMusic].forEach((input) => {\n        input.addEventListener("input", () => applyNodeChanges({ silent: true }));\n      });\n      el.choiceOptionsEditor.addEventListener("input", () => applyNodeChanges({ silent: true }));\n\n      restoreDraft();\n      renderNodes();\n      selectNode(state.scenario.entryNodeId || "n_start");\n    </script> </body> </html>'])), renderHead(), defineScriptVars({ defaultScenario, playerBaseUrl }));
}, "/Users/uiwwsw/visual-novel/apps/studio/src/pages/index.astro", void 0);
const $$file = "/Users/uiwwsw/visual-novel/apps/studio/src/pages/index.astro";
const $$url = "";

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$Index,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

const page = () => _page;

export { page };
